## TCP 粘包
tcp面向流传输.  
现象是解析包的时候把多个包一起解析了.  
```ditaa
粘包
  ─────────────────────▶
                        
 ┌──────────┬──────────┐
 │ package2 │ package1 │
 └──────────┴──────────┘
                        
                        
正常                        
             ──────────▶
 ┌──────────┬──────────┐
 │ package2 │ package1 │
 └──────────┴──────────┘
                        
                        
拆包                        
     ────────────────▶  
┌──────────┬──────────┐ 
│ package2 │ package1 │ 
└──────────┴──────────┘ 
```


- 发送方等缓冲区满才发包,发送多个包
    - tcp协议造成.tcp为了提高传输效率,发送方搜集到足够多的数据才发送一包数据.导致数据包同时发送
- 接收方不及时处理缓冲区的包,导致接收多个包
    - 处理数据不及时,缓冲区发送
- 避免粘包的措施
    - 数据段固定长度,位数不足的空位补齐
    - 消息体+消息头结构,明显区分包
    - 特殊字符(例如回车符等)
    - 应用层协议(消息结构的进化版)


## 大数据进行中位数评估
100亿数据,找中位数
思路: 取出1亿,先大约根据区间(例如 10000000作为桶),把数据放入不同的桶中.使用数据结构(例如二叉树)进行排序,并且统计桶的元素个数  
然后对每个桶在后续99亿数据进行放入桶和统计元素的操作  
最后根据同的范围,进行元素的中位数计算,找出中间段.中间段数据在内存中进行排序,获取对应的元素

## 二叉树搜索最大值
```cpp

int GetMax(void * pTree){
    if(pTree->left == NULL && pTree->right == NULL) return pTree->value;
    if(pTree->left == NULL && pTree->right != NULL) return max(pTree->value, GetMax(pTree->right));
    if(pTree->right == NULL && pTree->left != NULL) return max(pTree->value, GetMax(pTree->left));
    return max(pTree->value,max(GetMax(pTree->left), GetMax(pTree->right)));
}


```

## read的时候有数据就会被read,这个数据是多少?
//TODO

## mmap机制
- 分配连续虚拟地址空间
- 通过inode定位到文件磁盘地址
- 通过remap_pfn_range建立页表,实现文件地址和虚拟地址区域映射关系.这时候虚拟地址没有数据关联到内存,但是虚拟地址->实际物理内存->磁盘文件地址关系得到映射
- 访问数据的时候物理内存没有对应页,发生缺页终端,此时才会把磁盘数据拷贝到物理内存中,进程通过页表映射可以读取磁盘数据
- 读写后数据是根据内核进行同步到磁盘的.对实时性强的情况可以使用msync()强制同步

### 对比read write
```ditaa
read
 ┌────┐         ┌──────────────┐        ┌────────────────┐        ┌────┐
 │proc│────────▶│  user cache  │───────▶│  kernel cache  │───────▶│file│
 └────┘         └──────────────┘        └────────────────┘        └────┘
                                                                        
                                                                        
                                                                        
                                                                        
                                                                        
mmap                                                                       
┌────┐                       ┌────────────────┐                  ┌────┐ 
│proc│──────────────────────▶│  kernel cache  │─────────────────▶│file│ 
└────┘                       └────────────────┘                  └────┘ 
```
mmap对比read好处是可以对**大文件**进行方便的文件读写.但是缺页终端代价较大,例如需要开辟4k内存,内核中断.对于**小文件**其实是可以使用read的方式进行读写.但是如果存在多个进程读写同一个文件的情况,使用mmap会更适合

python decorator

## 大量小文件的读写挑战
fd上限,需要情况可以配置内核参数  
读取写入的时候同步刷新.因为linux不是同步写入,需要的话使用fsync  
因为使用read的时候会有用户态和内核态的cache,量大的时候可能占据内存较多  
如果读写的内存足够大,而且多进程读取,存在访问相同文件的情况应该用mmap,减少多余的内存消耗

## 在什么时候epoll会有EPOLLIN的触发
- send
- write
- accept
- 对端拔网线,socket会有epollin

## 查询等待关闭连接的个数  
netstat -n

## 正则表达式 小数
- 整数 ^([0-9]{1,})$
- 小数 ^([0-9]{1,}[.][0-9]*)$

100亿数据  

## 编码异常导致问题
- 内存泄漏
    - valgrind是动态还是静态
- 阻塞
- 死锁
- 不合理的循环调用(比如可以使用cache实现的,使用了rpc)

linux中有哪些锁?锁的区别?
mutex和文件锁的区别
注意:mutex可以在进程之间使用,使用mmap

## 智能指针的机制
本质是一个类  
在建立栈的时候构造类,在析构栈的时候析构类.在
退出作用域的时候c++ object的析构对象会自动调用,这里会检查引用计数.引用计数==0进行对应对象的析构

# 分界线

## valgrind可检查fd泄漏
针对情况:server端没有及时关闭socket,导致close_wait状态  

## preactor reactor
preactor类似reactor,但是reactor需要在用户态进行fd行为的操作,但是preactor内核态进行了fd行为的操作

## pthread_mutex 用法
一般pthread_mutex用法是使用智能指针,在退出栈的时候自动释放,这样就不怕线程退出的时候因为没有退出锁导致的死锁

## c++的private变量  怎样用函数访问
使用friend函数  

## valgrind 用法  原理
是动态监测,使用虚拟cpu,模拟运行.  
记录cpu的cache以及栈的内存  
```
全局数据(data, bss section)--在程序启动的时候标记为合法地址

局部变量--监控sp(stack pointer)的变化，动态维护

动态分配的内存--截获 分配/释放 内存的调用 ：malloc, calloc, realloc, valloc, memalign, free, new, new[], delete and delete[]

系统调用--截获mmap映射的地址

其他--可以显示知会memcheck某地字段是合法的

```


### 内存泄漏有几种
```
- “definitely lost”：确认丢失。程序中存在内存泄露，应尽快修复。当程序结束时如果一块动态分配的内存没有被释放且通过程序内的指针变量均无法访问这块内存则会报这个错误. Definitely lost又分为两种：直接的（direct）和间接的（indirect）。直接和间接的区别就是，直接是没有任何指针指向该内存，间接是指指向该内存的指针都位于内存泄露处。在上述的例子中，根节点是directly lost，而其他节点是indirectly lost。

- “indirectly lost”：间接丢失。当使用了含有指针成员的类或结构时可能会报这个错误。这类错误无需直接修复，他们总是与”definitely lost”一起出现，只要修复”definitely lost”即可。例子可参考我的例程。

- “possibly lost”：可能丢失。大多数情况下应视为与”definitely lost”一样需要尽快修复，除非你的程序让一个指针指向一块动态分配的内存（但不是这块内存起始地址），然后通过运算得到这块内存起始地址，再释放它。例子可参考我的例程。当程序结束时如果一块动态分配的内存没有被释放且通过程序内的指针变量均无法访问这块内存的起始地址，但可以访问其中的某一部分数据，则会报这个错误。

- “still reachable”：可以访问，未丢失但也未释放。如果程序是正常结束的，那么它可能不会造成程序崩溃，但长时间运行有可能耗尽系统资源，因此笔者建议修复它。如果程序是崩溃（如访问非法的地址而崩溃）而非正常结束的，则应当暂时忽略它，先修复导致程序崩溃的错误，然后重新检测。 

- “suppressed”：已被解决。出现了内存泄露但系统自动处理了。可以无视这类错误。这类错误我没能用例程触发，看官方的解释也不太清楚是操作系统处理的还是valgrind，也没有遇到过。所以无视他吧~
```
- 确认丢失:程序结束时候内存没有释放或者通过指针无法访问内存
- 间接丢失:指向该内存的指针都位于内存泄漏区域(内存泄漏区域中有指针指向的其他区域)
- 可能丢失:程序结束时动态分配内存没有释放,程序指针无法访问内存起始地址,但是能访问部分地址.
- 可以访问:未丢失未释放.长期运行可能会占据系统资源
- 已经解决:有泄漏但是系统自动处理.可以忽略

## 为什么需要内存对齐
- 平台原因.有的cpu如果没对齐,例如较旧的arm cpu,会报错
- 效率原因.原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

### pragma pack(n)
用于调整对齐大小

## mysql优化策略

## 系统资源
### cpu
ps aux | sort -k3nr |head -n 10   
top (之后P)  

### 跟踪系统调用
strace -c -p <pid>  运行一段时间之后ctrl c 可以看到调用的系统资源

### 内存
ps aux | sort -k4nr |head -n 10  
top (之后M)
pmap -xq <pid> 查看内存,映射内存

### 磁盘 
iostat 1 10 1s更新一次,更新10次

### 网络
netstat -tunlp  查看监听端口&进程
netstat -rn  主机路由信息
netstat -anoptcp  能看到进程对端的ip port


## virtual析构函数  
如果A:B 单纯析构A可能不会析构干净(B内容可能没有析构),但是如果析构A使用virtual, 能把B析构干净  
有虚函数的类应该是使用虚析构函数  
和普通的虚函数一样,只是虚析构函数也是派生类实现了虚函数的具体逻辑,在析构的时候会调用到对应派生类的析构函数.这样操作能保证析构干净.如果不是虚析构函数,对于`父类=new 子类()`,delete 父类的时候存在的问题是:无法析构干净

## public protect机制  

## 卡在close_wait是什么问题?
被动端没有在对端关闭的情况下close fd.(read==0的时候应该close(cfd))  
不继续处理可能的情况是:连接泄漏,占据过多fd  

## ng多机器负载均衡



