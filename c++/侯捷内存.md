# primitives

linux中的malloc使用dl_malloc doug lea

operator::new就是malloc
- while循环中malloc分配
- 如果mallc失败,使用自己制定的new handler,可以的话应该在new handler中释放掉一些无用的内存,因为内存不够才会到new handler
- catch上述异常
delete就是free
编译器进行malloc的内存分配

调用new的时候  过程是:
- 使用operator::new分配类的空间
- 指针指向分配的空间
- 编译器使用初始值初始化类
- catch上述异常 可能分配内存失败

使用delete时候,编译器转为operator delete删除
operator delete使用free删除

**注意**平时用的new不是operator::new 编译器转换到的才是operator::new

string是宏定义 对应的是basic_string

gcc不能直接调用构造函数
```cpp
A *pa = new A(1);
pa->A::A(3);//gcc失败
A::A(5);//gcc失败
```

### array new array delete
```cpp
C *pc = new C[3];//会构造3次,无法传初始值
delete[] pc;//会释放3次
//很容易因为忘记用delete[] 而使用delete 漏了释放内存
```
malloc分配内存的时候会写上cookie,写入内存的相关信息
最后会在cookie里写入object的信息
![内存分配](../imgs/stl/malloc内存分配.png)


如果只使用delete不使用delete[]释放
![释放不干净](../imgs/stl/malloc没有释放对象数据内存.png)
根据不同的编译器,要么释放上面的object,要么释放下面的object
内存释放不干净,导致内存泄漏

**使用array new 就应该用array delete**

手工构造 对对象数组初始化
```cpp
#include <iostream>
using namespace std;
class A
{
public : int id;
         A() :id(0){cout << "default ctr.this=" <<this<<"id="<<id<<endl;}
         A(int i):id(i){cout << "ctor.this="<<this<<"id="<<id<<endl;}
         ~A(){cout <<"dtor.this="<<this<<"id="<<id<<endl;}
};
int main()
{
    int size=3;
    A* buf = new A[size];
A* tmp = buf;
for(int i = 0; i < size; ++i)
{
    new(tmp++)A(i);//定点new(placement new) 会在原有地址上new以及构造
}
delete[] buf;//gnc c会从下往上析构
    return 0;
}
```
输出
```bash
default ctr.this=0x2143018id=0
default ctr.this=0x214301cid=0
default ctr.this=0x2143020id=0
ctor.this=0x2143018id=0
ctor.this=0x214301cid=1
ctor.this=0x2143020id=2
dtor.this=0x2143020id=2
dtor.this=0x214301cid=1
dtor.this=0x2143018id=0
```

#### 额外开销
例如在vc6下申请内存空间
```cpp
int* pi = new int[10];
delete pi;
```
vc6开辟的内存如下(debug mode下)
![](../imgs/stl/malloc_int_array.png)
对于整数的array,直接delete可以

但是如果申请的是对象数组
```cpp
D *p = new D[3];
delete[] p;
```
内存如下
![](../imgs/stl/malloc_object_array.png)
如果没有delete [] 直接delete,vc发现delete一个指针,但是发现内存布局不是,会报错
如果析构函数是默认的,不会记录这个3

#### placement new
允许在已经申请的内存里构建object
```cpp
char* buf = new char[sizeof(X)*3];
X *px = new(buf)X(12);
```
//TODO 如果构建的object和申请的内存不符会怎样
编译器不会再分配内存
编译器中的placement new:
```cpp
X *Pc
try{
    void *men = operator::new(sizeof(X),buf);//拿地址,不申请
    pc = static_vast<X*>(mem);
    pc->X::X(12);//构造
}
catch(std::bad_alloc){
    //失败就不构造
}
```

#### 重载
如果内存池 可以减少cookie损耗,值得做.
一个类可以重载 operator new 和operator delete
一般只改类自己的operator new 不会改全局的::operator new 因为全局的是所有类都依赖的,全局改可能不可可控
容器中不希望直接使用malloc free ,因此contruct和destroy会额外处理内存,在分配器里处理

重载::operator new/::operator delete
```cpp
inline void* operator new(size_t size){};
inline void* operator new[](size_t size){};
inline void* operator delete(void* ptr){};
inline void* operator delete[](void* ptr){};

```
类中重载new/delete
```cpp
class Foo{
    public:
    void* operator new(size_t);//需要静态,因为对象还没有构造的时候就要调用
    void operator delete(void*, size_t);//第二个参数optional//需要静态,因为对象还没有构造的时候就要调用
    void* operator new[](size_t);//需要静态,因为对象还没有构造的时候就要调用
    void operator delete[](void*, size_t);//第二个参数optional//需要静态,因为对象还没有构造的时候就要调用
}
```
在编译器调用构造/析构的时候
```cpp
//构建
try {
    void* mem = operator_new(sizeof(Foo));
    p=static_cast<Foo*>(mem);
    p->Foo::Foo(xx);
}

//析构
p->~Foo();
operator delete(p);
```
编译器的代码就会调用到类自己重载的代码进行构建/析构
如果使用::new ::delete 会绕过类自己定义的new delete,强制使用全局的new delete
ex:
```cpp
Foo *p = ::new Foo(7);
::delete p;

Foo *pA=::new Foo[5];
::delete[] pA;
```

重载placement new
可以自定义不同版本的placement new,但是第一个入参必须要size_t

//猜想:可能因为现在内存已经不值钱,后续的gnu版本没有针对地对内存做malloc的优化
 #### class allocator 
 内存池管理的目标:
 - 速度 减少malloc次数
 - 空间 减少cookie的个数

class中多一个next指针,把内存按照链表管理,并列存放
先拿到内存,初始化内存(各个类实例空间)然后挨个返回.
最后的实例会在这块内存空间中,直接指向对应的空间
![](../imgs/stl/per_class_allocator_1.png)


进化版本
使用union
可能有不同的member,但是可以用里面不同的member角度来看.
把一个union的前4个当做指针来看
实现
![](../imgs/stl/per_class_allocator_2.png)
使用union,类自己的存储就会有两种形态:类自己或者是next指针.初始化的时候使用next用来找到下一个待实例化的指针,类自己在实例化后可以使用该空间.
更多union看[这里](../c++/union.md)

delete都是把指针放给头指针,**事实上空间会空着**

#### static allocator
集中一个地方进行申请,不管什么class.这样不需要针对单独的类设计内存分配器
对象中加入privete static allocator 用于分配

allocator类中使用
```cpp
struct obj{
    struct obj* next;
}
```
用于指向下一个对象的位置
因为allocator是静态类,因此会在静态区间.因为next指向的是类自己,因此在分配的时候,**不需要类自己union一个next指针**,交给allocator指向即可
//TODO 删除后的空间怎么办??释放掉的空间就在里面没有再用或者移走



 


















