#  网络


## 分层模型

### OSI分层模型

- 物理层

- 数据层

- 网络层

- 传输层

- 会话层

- 表示层

- 应用层

### TCP/IP模型

- 内核

	- 链路层(网络接口层).以太网帧协议

	- 网络层.IP协议

	- 传输层.TCP/UDP协议

- 用户

	- 应用层.FTP/HTTP/telnet协议

## 常见协议格式

### 以太网帧格式

- ARP协议

	- 根据IP地址获取mac地址

- RARP协议

	- 根据mac地址获取IP地址

- 主要格式

	- mac source

	- mac destination

	- 类型

		- 0800:数据报

		- 0806:ARP包

		- 0835:RARP包

	- 1500字节

### IP端格式

- IP:指定网络中唯一一个终端

- 主要格式

	- 4位版本号

		- IPV4

		- IPV6

	- 4位首部长度

	- 16位总长度

	- 8位生存时间

		- TTL:time to live

		- 255

	- 32位源IP

	- 32位目的IP

		- IP地址共4字节

		- 每个字段上限256

### UDP数据报格式

- 主要格式

	- 16位源端口号

	- 16位目的端口号

		- 65535

### TCP数据报格式

- 主要格式

	- 16位源端口号

	- 16位目的端口号

	- 32位序号

	- 32位确认序号

		- 保证数据可靠传输

	- 4位首部长度

	- 标志位

		- SYN

		- ACK

		- FIN

		- RST

		- PUSH

		- ...

	- 16 位窗口大小

		- 65535

## TCP协议

### 通信时序

- 三次握手

	- SYN

	- SYN ACK

	- ACK

- 四次松手

	- FIN

	- ACK

	- FIN

	- ACK

### 滑动窗口

- win

- 流量控制

### MTU

- 最大传输单元

### mss

- 最大报文长度

### 半关闭

- 通信双方的一方单向关闭连接

- 四次松手完成1/2

- shutdown()

	- sockfd

	- how

		- SHUT_RD

			- sockfd不能读 (读不到数据)

		- SHUT_WR

			- 进程不能向socket写数据

				- 此时半关闭

		- SHUT_RDWR

- 进入FIIN_WAIT_2

### TCP状态转换图

- ESTABLISHED

- FIN_WAIT_2

- TIME_WAIT

	- ˙主动关闭连接一方

	- 发出ACK后

	- 2MSL

		- 保证4次握手关闭连接可靠

### 心跳检测

- 心跳包

- 乒乓包

- TCP自带(2小时+11分15s)

### 端口复用

- setsockopt

## socket编程

### 套接字

- Linux特殊文件类型(管道,套接字,字符设备,块设备)

- 文件描述符fd,索引两个缓冲区(读,写)

- 成对出现(C/S,B/S)

- 捆绑IP,端口号(网络)

### socket预备知识

- 网络字节序

	- 大端发(高存低)

	- htonl

		- 本地字节序->网络字节序(IP)

	- htons

		- 本地字节序->网络字节序(端口)

	- ntohl

	- ntohs

- IP地址转换

	- inet_pton

		- 参数

			- af

				- AF_INET

				- AF_INET6

			- src

				- IP地址字符串

			- dst

				- IP地址数字存储形式

		- 返回值

			- 成功

				- 0

			- 失败

				- -1

	- inet_ntop

		- 参数

			- af

				- AF_INET

				- AF_INET6

			- src

				- IP地址数字存储形式(网络中)

			- dst

				- 获取来的IP字符串存储位置

				- 传出参数

			- size

				- dst的大小

		- 返回值

			- 成功

				- dst指针

			- 失败

				- NULL

- sockaddr结构体

	- 过时

	- sockaddr_in结构体

		- 用于捆绑IP,端口号

		- 成员

			- sin_family

				- AF_INET

				- AF_INET6

				- AF_UNIX

			- sin_port

				- 16位整数

			- sin_addr结构体

				- s_addr

				- 32位无符号整数

				- INADDR_ANY

	- sockaddr_in6

### 网络套接字函数

- socket模型流程图

	- client

		- socket()

		- connect()

		- read()

		- write()

		- close()

	- server

		- socket()

		- bind()

			- sockaddr_in

				- sin_family

				- sin_port

				- sin_addr.s_addr

		- listen()

			- 最大128

		- accept()

		- read()

			- 返回0:对端关闭

		- write()

		- close()

- socket()

	- 创建一个套接字

	- 参数

		- domain

			- AF_INET

			- AF_INET_6

			- AF_UNIX,AF_LOCAL

		- type

			- SOCK_STREAM

				- 代表协议:TCP

			- SOCK_DGRAM

				- 代表协议:UDP

		- protocol协议

			- 0表示默认协议

	- 返回值

		- 成功

			- 新创建的socket fd

		- 失败

			- -1

			- errno

- bind()

	- 绑定IP port到套接字

	- 参数

		- sockfd

		- addr

			- 类型:struct sockaddr*

			- 传参

				- 定义 struct sockaddr_in addr

				- 初始化addr成员

					- sin_addr.s_addr

					- sin_port

					- sin_family

				- (struct sockaddr*)&addr 强转

		- addrlen

			- 类型:socklen_t

			- addr大小 sizeof(addr)

	- 返回值

		- 成功

			- 0

		- 失败

			- -1

			- errno

- listen()

	- 允许处于连接状态的client数

	- 参数

		- sockfd

		- backlog

	- 返回

		- 成功

			- 0

		- 失败

			- -1

			- errno

- accept()

	- 阻塞监听客户端连接

	- 参数

		- sockfd

		- addr

			- 客户端地址结构(IP+端口)

			- 传出参数

			- (struct sockaddr*)&addr 强转

		- addrlen

			- addr大小

			- socklen_t类型

			- 传入传出参数

	- 返回值

		- 成功

			- 返回用于与客户端通信的fd

		- 失败

			- -1

			- errno

- connect()

	- 参数

		- sockfd

		- addr

			- 服务器地址结构(IP+端口)

			- 传入参数

			- (struct sockaddr*)&addr强转

		- addrlen

			- addr大小 sizeof(addr)

	- 返回值

		- 成功

			- 0

		- 失败

			- -1

			- errno

## 高并发服务器

### 多进程并发

- 防止僵尸进程

- 捕捉SIGCHLD信号

### 多线程并发

- 线程分离

### 多路IO转接

- select

	- select()

		- 参数

			- ndfs

				- 锁监听的最大fd + 1

					- 性能可能有问题,内核根据ndfs来监听,如果剩下fd是3 1000,事实上会轮训了到1001

			- readfds

				- 有数据刻度的fd集合(传入,传出)

			- writefds

				- 可写的fd集合(传入,传出)

					- lfd可读:有连接请求进来.

					- cfd可读:说明cli往socket写数据

			- exceptfds

				- 有异常发生的fd集合(传入,传出)

					- 主要供内核使用,日常使用较少

			- timeout

				- NULL:永久等待

				- 0 不阻塞

				- 具体时间:阻塞时间

		- 返回值

			- 成功

				- 所有监听集合中满足条件的总数

			- 失败

				- -1

				- errno

	- fd_set类型

	- 辅助函数

		- FD_ZERO

			- 清空集合

		- FD_SET

			- 将某个fd加入集合

		- FD_CLR

			- 将某个fd清出集合

		- FD_ISSET

			- 判断fd是否在集合中

				- 每次都要调用方自己判定,传入还要重新传.效率不高

- poll

	- struct pollfd结构体

		- fd

			- 要监听的fd

		- events

			- 监听该fd什么事件

				- POLLIN

				- POLLOUT

				- POLLERR

		- reevents

			- 满足条件返回的事件

	- poll()

		- 参数

			- fds

				- 监控数组

			- nfds

				- 监控数组中需要监控的fd数量

			- timeout

				- -1:阻塞等

				- 0:立即返回

				- >0 等待时长

		- 返回值

			- 成功

				- 所有监听集合中满足条件的fd数

			- 失败

				- -1

				- errno

	- 比较select()优势

		- 突破1024限制

		- 传入,传出事件分离

- 修改进程打开fd

	- 查看

		- cat /proc/sys/fs/file_max

			- 硬件限制-物理层面

		- ulimit -a

			- openfiles,软件限制

	- 修改

		- sudo  vi /etc/srcurity/limits.conf

		- *soft nofile 8000

			- 设定默认打开fd数

		- * hard nofile 10000

			- 限定命令临时修改上限

			- ulimit -n xxxx

		- 重启,注销用户

- epoll

	- epoll_create

		- 创建一棵监听红黑树

			- 根:epfd

		- 参数size:希望监听的fd个数(内核参考值)

		- 返回值

			- 成功

				- 新创建的监听红黑树对应的fd epfd

			- 失败

				- -1

				- errno

	- epoll_ctl

		- 参数

			- epfd

				- epoll_create返回的监听树epfd

			- op:操作动作

				- EPOLL_CTL_ADD

					- 添加一个新fd到监听红黑树

				- EPOLL_CTL_MOD

					- 修改一个已经监听fd的监听事件

				- EPOLL_CTL_DEL

					- 从epfd清出一个监听fd

			- fd

				- 待监听fd

			- event

				- 需要监听的事件

				- 类型:struct epoll_event

				- 成员

					- events

						- EOPLLIN

						- EPOLLOUT

						- EPOLLERR

					- data

						- union

							- 用户自定义信息,用于回调事件

						- int fd

						- void *ptr

						- uint32_t u32

						- uint64_t u64

		- 返回值

			- 成功

				- 0

			- 失败

				- -1

				- errno

	- eopll_wait

		- 参数

			- epfd

				- eopll_create返回的监听树fd

			- events

				- 传出参数,传出满足监听事件的数组

			- maxevents

				- 数组元素总个数

			- timeout

				- -1 阻塞

				- 0 不阻塞

				- >0 指定毫秒阻塞

		- 返回

			- 成功

				- 满足监听条件的fd总数,用作数组循环上限

			- 0

				- timeout时间到

			- 失败

				- -1

				- errno

	- 优势

		- 突破1024限制

		- 事件分离

- eopll进阶

	- epoll_ET

		- Fd可以可读触发或者可写触发才会响应

		- 关注事件触发,fd的内容变动

		- 对于读监听,必须是有写进程触发过fd才可以被读监听侧监听到

	- epoll-LT

		- 默认

		- Fd可写或者可读就会响应,不需要事件触发

		- 只要fd内有数据,读监听侧就会收到监听触发

	- 非阻塞IO+ET

		- ET

			- EPOLLIN|EPOLLET

		- 非阻塞

			- flg=fcntl(fd,F_GETFL)

			- flg |= O_NONBLOCK

			- fcntl(fd,F_SETFL,flg)

	- epoll反应堆模型

		- 监听事件变化

			- EPOLLIN 转为 EPOLLOUT

			- 事件被触发之后,需要先从监听树上摘下来,从新挂在树上

			- 所有事件,包括lfd的监听,都使用eopll完成

			- 依靠epoll挂在树上的时候的event结构体,可以返回用户指定的内容,在里面挂上调用函数,达到反应的目的

		- 回调函数

			- 自动反应

- 线程池

	- threadpool_task_t

		- 全局总控

	- main

		- threadpool_create创建线程池

		- for产生任务

			- 阻塞在queue_not_full条件变量上

		- threadpool_add添加任务

		- threadpool_destroy销毁线程

	- threadpool_create()

	- threadpool_thread()

		- 跟踪到pthread_cond_wait()阻塞

			- 阻塞在queue_not_empty条件变量上

	- threadpool_add()

		- 跟踪到pthread_cond_signal(), 回上步,继续pthread_cond_wait()

	- adjust_thread

		- 根据线程数量和alive线程数调整线程

			- pthread_exit()

	- thread_destroy

		- 销毁整个线程池

			- pthread_exit()

## UDP

### 协议对比

- TCP

	- 面向连接的可靠数据传输

		- 针对不稳定的网络层,依靠重发弥补

	- 优点

		- 稳定

			- 正确率

				- 丢包重传

			- 传递顺序

			- 流量

	- 缺点

		- 开销大

		- 速度慢

	- 使用场所

		- 大文件

		- 重要文件

- UDP

	- 无连接的不可靠报文传递

		- 针对不稳定网络层,完全不弥补

	- 优点

		- 开销小

		- 速度快

		- 效率高

		- 实时性强

	- 缺点

		- 不稳定

			- 正确率

				- 丢包不作为

			- 传递不按顺序

			- 流量不进行控制

	- 使用场所

		- 实时性较强

		- 游戏

		- 视频电话,会议

### UDP c/s服务器

- 通信步骤

	- server

		- socket()

		- bind()

			- 绑定IP port

		- recvfrom()

			- 接收数据

		- sendto()

			- 回发数据

	- client

		- socket()

		- 隐式绑定

		- sendto()

			- 发送数据

- recvfrom()

	- 参数

		- sockfd

		- buf

		- len:bufsize

		- flags:0

		- src_addr

			- 对端地址结构体(传出)

		- addrlen

			- 地址结构大小(传入传出)

	- 返回值

		- 实际接收字节数

- sendto()

	- 参数

		- sockfd

		- buf

		- len:bufsize

		- flags:0

		- dest_addr

			- 服务器端的地址结构(传入),参数不能省略

		- addrlen

			- 地址结构大小

	- 返回值

		- 实际发送字节数

- 默认支持多路IO

- 无连接:无状态

	- netstat-apn

	- TCP状态时序图

- send,recv只能用于TCP连接的C/S模型

## 本地套接字

### socket()

- AF_UNIX/AF_LOCAL

### bind()

- sockaddr_un

	- sun_family

		- AF_UNIX

	- sun_path

		- “path”

- (struct sockaddr*)&addr

- len

	- offset()

		- 结构体成员首地址偏移

		- 获取AF_UNIX大小

		- offsetof(struct sockaddr_un,sun_path)

	- strlen()

		- 实际socket文件大小

- 创建socket文件

	- 先unlink,确保bind成功

### 客户端

- 不能依赖隐式绑定

- 2次地址结构初始化

	- client_addr

		- bind()

	- server_addr

		- connent()

### 对比网络socket和本地socket


# 网络

### 协议
数据存储的规则,数据传输的规则

例如:传输文件的时候,开始先传文件名,然后传大小,然后传内容 -->ftp 的前身

分层模型结构
OSI 
七层模型,物数网传会表应
TCP/IP 
四层模型 网(链路层/网络接口层)网(网络层)传(传输层)应(应用层)
应用层: http ftp nfs ssh telnet
传输层: tcp udp
网络层: ip icmp igmp
链路层: 以太网帧协议,ARP协议

数据经过一层层的封装,最后在链路层进行传输.对端拿到包之后一层层解封,获取数据.
```ditaa
                                                                                                 
                     A                                                     B                     
                 ┌───────┐                                             ┌───────┐                 
                 │ data  │                                             │ data  │                 
                 └───────┘                                             └───────┘                 
                     │                                                     ▲                     
                     │                                                     │                     
                     │                                                     │                     
                     │                                                     │                     
                     ▼                                                     │                     
             ┌──────────────┐                                      ┌──────────────┐       ▲      
     │       │     data     │                                      │     data     │       │      
     │       ├──────────────┤                                      ├──────────────┤       │      
     │       │ application  │              user                    │ application  │    depackage 
     │    ───┼──────────────┼──────────────────────────────────────┼──────────────┼──▶    │      
 package     │transportation│            kernel                    │transportation│       │      
     │       ├──────────────┤     ─────────network─────────▶       ├──────────────┤       │      
     │       │   network    │                                      │   network    │       │      
     │       ├──────────────┤                                      ├──────────────┤       │      
     ▼       │     link     │                                      │     link     │       │      
             └──────────────┘                                      └──────────────┘              
```

应用层需要用户对数据进行封装.
传输层开始内核封装.
 
```ditaa
                                                      ┌────┐               
                                                      │data│               
                                                      └────┘               
                                                                           
                                                                           
                                                                           
                                     ┌────────────────┬────┐               
                                     │application head│data│               
                                     └────────────────┴────┘               
                                                                           
                                                                           
                                                                           
                          ┌──────────┬────────────────┬────┐               
                          │ TCP head │application head│data│               
                          └──────────┴────────────────┴────┘               
                                                                           
                                                                           
                                                                           
               ┌──────────┬──────────┬────────────────┬────┐               
               │ IP head  │ TCP head │application head│data│               
               └──────────┴──────────┴────────────────┴────┘               
                                                                           
                                                                           
┌──────────────┬──────────┬──────────┬────────────────┬────┬──────────────┐
│ethernet head │ IP head  │ TCP head │application head│data│ethernet tail │
└──────────────┴──────────┴──────────┴────────────────┴────┴──────────────┘
```

#### 以太网帧格式
```ditaa
┌────────────────┬─────────────┬─────────┬──────────────────────────────────────────────────┬────────┐
│MAC destination │ MAC source  │  type   │                       data                       │  CRC   │
└────────────────┴─────────────┴─────────┴──────────────────────────────────────────────────┴────────┘
                                                                                                      
 ─────────6──────▶──6──────────▶─2───────▶───────────────────46-1500────────────────────────▶──4─────▶
                                                                                                      

```
MAC地址:网卡硬件地址.厂商生产网卡的时候需要申请mac的空间.
目标MAC地址:在发送数据之前发送ARP请求获取MAC地址

#### ARP
ARP协议:根据IP地址获取mac地址 
ARP请求帧可以理解成以太网帧格式的一种特例

请求
```ditaa
┌─────────────────┬─────────────┬────┬─────┬──────────────┬──────────────┬────────────────┬──────────────┬────────┐
│ff:ff:ff:ff:ff:ff│ MAC source  │0806│8 bit│  MAC source  │  IP source   │ff:ff:ff:ff:ff:f│IP destination│  CRC   │
└─────────────────┴─────────────┴────┴─────┴──────────────┴──────────────┴────────────────┴──────────────┴────────┘
```
当前目标mac地址不知道,因此请求中都打上ff..ff
ARP请求发送后,在路由中转.路由表记录和路由器连接的其他路由器地址.路由对路由表的连接路由进行广播.如果是ARP的包头请求,收到的路由器会查看本机IP地址是否与请求包中目标IP地址一致,一致的话就回包,在回包中加上目标mac信息.不一致就丢弃.
回报的时候因为是发给source机器,因此发包的时候source的mac是自己的mac,但是目标mac就是请求中的source mac.包文中的信息也同样替换
根据格式填充的包文
```ditaa
┌─────────────┬────────────────┬────┬─────┬────────────────┬──────────────┬──────────────┬──────────────┬────────┐
│ MAC source  │MAC destination │0806│8 bit│MAC destination │IP destination│  MAC source  │  IP source   │  CRC   │
└─────────────┴────────────────┴────┴─────┴────────────────┴──────────────┴──────────────┴──────────────┴────────┘
```
RARP协议则是根据mac获取ip的请求 type是8035

#### 以太网帧格式
根据mac地址,完成数据报传输

#### IP协议

IP段格式
![](../imgs/network/ip_package_format.png)
**版本**:ipv4 ipv6 4位

**TTL**:time to live,这里time是次数.这里设置的是数据报在路由节点中的跳转上限.
有可能因为网络不通,到达不了的请求会在网路路由中不断找.
TTL是一个次数,每一跳(就是从一个路由器跳转到下一个路由器)都会-1.当TTL减少为0的时候,数据报被路由器丢弃,防止拥塞网络.

**32位源IP** 4字节    
**32位目标IP**  4字节

日常用的192.168.101.1 是转给人类看的,称为点分十进制IP地址.是字符串.   真正网络传输是二进制的IP地址.


IP地址:可以在网络环境中唯一表示一台主机.
port:可以在网络的一台主机上唯一表示进程
IP + port: 网络环境中标识唯一进程

一般是5000以下有指定,使用5000以上的端口号较好


#### UDP协议
![](../imgs/network/udp_package_format.png)
 


#### TCP协议
![](../imgs/network/TCP_package_format.png)
16位源端口号 2字节 2^16,65536 能描述最大的端口号
16位目的端口号 2字节 2^16 65536
32位序号
32位确认序号 相当于回执
6个标志位
16位窗口大小 65536


#### bs cs

||c s|b s|
|---|---|---|
|优点|缓存大量数据,协议选择灵活,速度快,|安全性好,跨平台,开发量小|
|缺点|安全性,不好跨平台,开发量大|不能缓存大量数据,严格遵守http|

#### 网络字节序
小端 intel提出.因为现在设备基本是intel芯片,所以很多机器是使用小端 little endian
高位存高地址,低位存低地址
ex:0x12345678
```ditaa
┌────┐ high
│ 12 │
├────┤
│ 34 │
├────┤
│ 56 │
├────┤
│ 78 │
└────┘ low
``` 

大端 IBM最初的协议.因为IBM最初做存储,因此网络使用大端 big endian
高位存低地址,低位存高地址
```ditaa
┌────┐  high
│ 78 │
├────┤
│ 56 │
├────┤
│ 34 │
├────┤
│ 12 │  low
└────┘
```

网络中使用大端解包.因此需要一次网络字节序和主机字节序的转换.

转换函数:
htonl //host to network long 本地转到网络(ip)
htons //host to network short 本地转网络(port)
ntohl //network to host long 网络转本地(ip)
ntohs //netowrk to host short 网络转本地(port)

### tcp/ip通信
![](../imgs/network/tcp_conn.png) 
#### 建立连接
大部分是客户端主动发起连接
![](../imgs/network/TCP_package_format.png)
客户端在标志位写上SYN 专门用于建立连接通信
下图的连接传输格式
mss:最长报文长度  maximum segment size
举例:
- SYN,1000(0),<mss 1460>
<当前标志位>,<当前序列号>(<当前数据大小>)<后续通信每个包的上限>
1460表示将来传输数据的时候数据的上限,
这个大小从以太网帧大小会得到控制
![](../imgs/network/ethernet_frame.png)
以太网的数据上限是1500,所以每个以太网帧的数据最大是1500.
但是在以太网数据中除了tcp数据还有ip头和tcp头
```ditaa
┌──────────────┬──────────┬──────────┬────────────────┬────┬──────────────┐
│ethernet head │ IP head  │ TCP head │         data        │ethernet tail │
└────14────────┴──────20──┴────20────┴────────────────┴────┴───────4──────┘
```
以太网帧的数据段大小是46-1500字节,因此tcp包的数据段是6-1460大小.

服务器**同意**建立连接的时候,标志位设成ACK 例如回包
- SYN,8000(0),ACK 1001,<mss 1024>
这里的1001表示:服务端给客户端说1001号包之前的数据我都收到了.
为什么是1001不是1000?客户端请求并没有带数据.
原因:因为客户端请求中有SYN标志位,**占一字节**.服务器认为收到了这一个字节的数据,意思是这个SYN标志位收到了.所以回包是1001,不是1000
<mss 1024>表示后续通信服务器发给客户端携带的数据上限是1024.
SYN 表示服务器要和客户端建立连接.
因为tcp是双向通信,不是单向通信,所以建立的是两条单向的连接.在前面ACK 1001看到服务端已经收到了客户端的SYN请求,到这里客户端->服务端的连接可以认为已经建立
8000表示服务器发送包的包号 0表示携带数据的大小

- ACK 8001
说明客户端受到服务端的连接请求,返回ACK <客户端包号>+1, 表示应答服务端的连接请求.
当服务器顺利收到ACK的时候,双方建立连接完成.

```ditaa
     │                                                  │    
     │                                                  │    
   cli                                                svr    
     │                                                  │    
     │                                                  │    
     ╳                                                  │    
     │╲                                                 │    
     │ ╲────────────────────SYN 1000(0)────────────────╲│    
     │                                                  ▼    
     │                                                  ╳    
     │                                                 ╱│    
     │╱────────────SYN 8000(0) ACK 1001───────────────╱ │    
     ▼                                                  │    
     ╳                                                  │    
     │╲                                                 │    
     │ ╲──────────────ACK 8001────────────────────────╲ │    
     │                                                 ╲│    
     │                                                  ▼  3次握手完成 (内核完成) 
     │                                                  │  cli:connect()成功执行并返回
     │                                                  │  svr:accept()成功执行并返回
     │                                                  │    
     │                                                  │    
     ▼                                                  │    
                                                        ▼    
```

#### 数据通信
cli->svr: 1001(20),ACK 8001
客户端向服务器发送数据.
- 1001:当前客户端的包号.
- 20:发送20字节数据过去.
- ACK 8001 前面连接已经建立,这一步其实可以不发送.但是鉴于复杂的网络情况:如果三次握手的时候,最后一个cli->svr的包ACK 8001没有发送到,或者因为网络阻塞等原因svr收到较晚,svr可能认为建立还没成功(因为没收到cli发来的答应).为了保险,把ACK 8001在第一次数据的时候也带上,这种情况下的数据发送svr会认同,并且数据接收成功.可以理解是一种**双保险**机制
ACK可以理解成一个回执.每次发数据/请求的时候都会带上,作为上一次对端数据发送的回执,告知对端数据的情况.

svr->cli: 8001(10),ACK 1021
- 8001:当前客户端的包号
- 10:发送10字节数据过去
- ACK 1021 cli的回执.表示1021号包之前的数据都已经收到.

包序号的问题:
每一端都管理自己的包号.例如:cli发送请求的时候,是1000 但是因为SYN标志位的原因,svr回包1001.后续发送数据的时候是1001开始.
可以理解成:1001包号发送的数据,里面的数据数是x.下个包号就是1001+x.也就是当前的序号是已经确认发送了的序号,然后未知道发送是否成功的大小,到了对端确认收成功的时候,把序号增加(表示已经传输成功)

cli->svr
- ACK 8011 8011号包之前的数据都已经收到了.

数据传输并不会每次都只发一个包.使用窗口机制可以批量发送.
![](../imgs/network/tcp_batch_send.png)
cli发送很多包,svr反馈都收到了很多包.

#### 关闭连接
有可能服务器,也有可能客户端发起.
更多是客户端发起关闭.
```ditaa
                                                  │     
    │                                             │     
    │                                             │     
   cli                                           svr    
    │                                             │     
    ╳                                             │     
    │╲                                            │     
    │ ╲──────FIN,1021(0),ACK 8011────────────────╲│     
    │                                             ▼     
    │                                             ╳     
    │                                            ╱│     
    │ ╱─────────────ACK 1022────────────────────╱ │     
    │╱                                            │     
    ▼                                             │    半关闭完成.这里是cli完成半关闭.cli->svr的通信关闭
    │                                             ╳    底层可以理解cli的**写缓冲关闭**.
    │                                            ╱│    但是此时svr->cli的通信还没关闭. 
    │╱─────FIN,8011(0),ACK 1022─────────────────╱ │     
    ▼                                             │     
    ╳                                             │     
    │╲                                            │     
    │ ╲───────────────ACK 8012───────────────────╲│     
    │                                             ▼    4次挥手断开连接 (全关闭)
    │                                             │     
    │                                             │     
    │                                             │     
    │                                             │     
    │                                             │     
    │                                             │     
    │                                             │     
    │                                             │     
    ▼                                             ▼     
```
注意:这里的1021是cli管的包序号.观察cli的包序号可以看到:cli或者svr的包序号都是根据自己已经确认被发送的包个数增上去的.
cli->svr: FIN,1021(0),ACK 8011
表示客户端关闭连接,当前包序号是1021,ACK应答之前收到的包号是8011(8011之前的都收到了)
svr->cli: ACK 1022
表示svr已经收到了这个请求,并且发给cli FIN这个信息已经收到了.
到这里完成了半关闭

注意:cli发起关闭tcp连接之后,svr后续是读不到的.因为cli的sfd已经把写缓冲区关闭.
svr如果read为0(暂时这样理解,应该有更好地办法识别到cli关闭了通信),可以进行关闭tcp连接
```ditaa
                                                                      │                        
                        │                                             │                        
                        │                                             │                        
    cli close(sfd)     cli                                           svr                       
                        │                                             │                        
                        ╳                                             │                        
                        │╲                                            │                        
    ┌────────────┐      │ ╲──────FIN,1021(0),ACK8011─────────────────╲│                        
    │ cli socket │      │                                             ▼                        
    │            │      │                                             ╳                        
    ├────────────┤      │                                            ╱│                        
    │  r buffer  │      │ ╱─────────────ACK 1022────────────────────╱ │    svr read(sfd) == 0  
    ├────────────┤      │╱                                            │                        
    │██w buffer██│      ▼                                             │                        
    └────────────┘      │                                             │                        
                        │                                             │                        
                        │                                             │                        
                        │                                             │      svr close(sfd)    
                        │                                             │                        
                        │                                             ╳                        
                        │                                            ╱│                        
                        │╱─────FIN,8011(0),ACK 1022─────────────────╱ │                        
                        ▼                                             │                        
                        ╳                                             │                        
                        │╲                                            │                        
                        │ ╲───────────────ACK 8012───────────────────╲│                        
                        │                                             ▼                        
                        │                                             │                        
                        │                                             │                        
                        │                                             │                        
                        ▼                                             ▼                        
```
服务器close关闭成功的时候,拿到cli的最后返回.

**半关闭**:
```ditaa
┌────┐─────────────────────────────────────────▶┌────┐ 
│cli │                                          │svr │ 
└────┘◀─────────────────────────────────────────└────┘ 
                                                       
                          │                            
                          │                            
                          ▼                            
┌────┐                                          ┌────┐
│cli │─────────────────────────────────────────▶│svr │
└────┘                                          └────┘
```
从原来全双工通信退化成单工通信.数据只能单方向传输.

svr->cli FIN,8011(0),ACK 1022
表示服务端关闭连接.当前包序列号是8011 之前cli发给svr的1022号包之前的都已经收到(此处包括了FIN这1个字节,和SYN类似)
cli->svr ACK 8012
收到了svr的关闭请求,断开连接

为什么需要4次挥手不是3次?
原因:半关闭 svr可能还有数据要发

服务器必须收到了最后一个cli->svr ACK 8012,才能确认关闭连接这个事情完成.
ex:svr->cli FIN,8011(0),ACK 1022发送后,一直没有收到cli->svr ACK 8012,此时svr**隔一段时间就会发送一次**svr->cli FIN,8011(0),ACK 1022,确保cli收到svr发出的关闭连接请求.

//TODO 关闭的socket 内核机制

### 滑动窗口 tcp流量控制
![](../imgs/network/tcp_batch_send.png)
16位的窗口大小,最大是65535

假定场景:发送方很开,但是接收方很慢.
接收方接收数据,本质是内核对这个sokcet的读buff接收可能过慢(例如进程较多,cpu处理不过来等)

如果接收方读buff已经满了,继续让发送方发送数据,可能导致读buff数据被覆盖.不可以发生.

服务器内部使用滑动窗口机制,指定缓冲区大小,让发送方根据指定的缓冲区大小发送数据.
如果缓冲区填满了,就告诉发送方先不要发

建立连接的时候,可以沟通滑动窗口win的大小.
建立连接时:
cli->svr win 4096 告知svr:cli的win是4096
svr->cli win 6144 告知cli:svr的win是6144

cli每次发数据时候都会把自己的win发送过去
在图示步骤4-9中,因为窗口大小是6144,因此sender直接发了5个包 5120大小.
再发的话会超 6145.因为超过了rcvr的win.
这时候  9 - 12 sender等待rcvr处理

步骤10:rcvr处理了滑动窗口中的部分字节,剩余2048字节可用.
步骤11:同上 处理多了点,剩余4096可以用.
利用滑动窗口不停接收和处理数据
把buffer当做窗口,已经处理的数据看成一个长的数据列

滑动窗口的目的是**防止数据丢失**

###32位序号 32位确认序号
每次返回的ACK的序号是32位确认序号(暂时理解为写缓冲处理完的序号)
告知对端当前发送的包序号是32位序号

这个序号最大是2^32


## tcp状态
netstat -apn |grep <port>
ex
```
➜  linux netstat -apn |grep 9999
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        0      0 0.0.0.0:9999            0.0.0.0:*               LISTEN      13918/./s
tcp        0      0 127.0.0.1:48924         127.0.0.1:9999          ESTABLISHED 13927/./c
tcp        0      0 127.0.0.1:9999          127.0.0.1:48924         ESTABLISHED 13918/./s
unix  2      [ ]         DGRAM                    6699991  -
```
可以看到 第一个fd是用于监听的,第三个是用于建立连接 (都是./s的)
第二个是cli的
监听的fd是LISTEN
建立连接的两个fd是ESTABLISHED

cli关闭后可以看到进入TIME_WAIT
```
➜  linux netstat -apn |grep 9999
(No info could be read for "-p": geteuid()=1000 but you should be root.)
tcp        0      0 127.0.0.1:48924         127.0.0.1:9999          TIME_WAIT   -
unix  2      [ ]         DGRAM                    6699991  -
```
//TODO  svr没有close主动退出进程, svr是fin_wait2 cli是close_wait 为什么
先关闭svr(没有close)然后再启动svr,启动失败,返回绑定地址事变
```
➜  linux netstat -apn |grep 9999
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
tcp        1      0 127.0.0.1:48948         127.0.0.1:9999          CLOSE_WAIT  20200/./c
tcp        0      0 127.0.0.1:9999          127.0.0.1:48948         FIN_WAIT2   -
unix  2      [ ]         DGRAM                    6699991  -
```

只有主动关闭的一方会进入TIME_WAIT

建立连接的时候如果svr在syn_rcvd状态没有收到cli的ack,会重新发送syn ack包,表示已经建立连接并且请求cli建立连接.防止网络原因丢包
其他状态下发送的请求也是,会不断重发.//TODO 发送时间多久

```ditaa
┌─────────────┐ │                                                  │ ┌─────────────┐
│             │ │                                                  │ │   CLOSED    │
│   CLOSED    │cli                                                svr├─────────────┤
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
├─────────────┤ ╳                                                  │ │   LISTEN    │
│             │ │╲                                                 │ │             │
│             │ │ ╲─────────────────────SYN 500(0)────────────────╲│ │             │
│             │ │                                                  ▼ │             │
│  SYN_SENT   │ │                                                  ╳ ├─────────────┤
│             │ │                                                 ╱│ │             │
│             │ │╱─────────────SYN 700(0) ACK 501────────────────╱ │ │             │
│             │ ▼                                                  │ │             │
├─────────────┤ ╳                                                  │ │  SYN_RCVD   │
│             │ │╲                                                 │ │             │
│             │ │ ╲──────────────ACK 701─────────────────────────╲ │ │             │
│             │ │                                                 ╲│ │             │
│             │ │                                                  ▼ ├─────────────┤
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
│ ESTABLISHED │ │                                                  │ │             │
│             │ ▼                                                  ▼ │             │
│             │                                                      │             │
│             │                                                    │ │             │
│             │ │                                                  │ │ ESTABLISHED │
│             │ │                                                  │ │             │
│             │ │ cli                                            svr │             │
│             │ │                                                  │ │             │
├─────────────┤ ╳                                                  │ │             │
│             │ │╲                                                 │ │             │
│             │ │ ╲────────FIN,1021(0),ACK8011────────────────────╲│ │             │
│             │ │                                                  ▼ │             │
│ FIN_WAIT_1  │ │                                                  ╳ ├─────────────┤
│             │ │                                                 ╱│ │             │
│             │ │ ╱───────────────ACK 1022───────────────────────╱ │ │             │
│             │ │╱                                                 │ │             │
├─────────────┤ ▼                                                  │ │ CLOSE_WAIT  │
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
│ FIN_WAIT_2  │ │                                                  ╳ ├─────────────┤
│             │ │                                                 ╱│ │             │
│             │ │ ╱──────────────────────────────────────────────╱ │ │             │
│             │ │╱        FIN,8011(0),ACK 1022                     │ │             │
│             │ ▼                                                  │ │  LASK_ACK   │
├─────────────┤ ╳                                                  │ │             │
│             │ │╲                                                 │ │             │
│             │ │ ╲──────────────────ACK 8012─────────────────────╲│ │             │
│             │ │                                                  ▼ ├─────────────┤
│             │ │                                                  │ │             │
│  TIME_WAIT  │ │                                                  │ │             │
│             │ │                                                  │ │             │
│             │ ▼                                                  ▼ │             │
│             │                                                      │             │
│           2MSL(~40s)                                               │   CLOSED    │
├─────────────┤                                                      │             │
│             │                                                      │             │
│   CLOSED    │                                                      │             │
│             │                                                      │             │
│             │                                                      │             │
└─────────────┘                                                      └─────────────┘

```

2MSL 为了保证最后一个ACK成功被对端接收
等待期间如果对端没有收到,对端会再发送FIN
2MSL发生在主动发生关闭连接一端.因为是为最后一个ack服务的,确保最后一个ack在网络中消失:
- 如果对端收不到最后的ack,在msl内应该要再次发送一个fin ack,因为对端应该在last_ack内是等待本端的ack请求
- 对端最后的ack发放到本端接收最多不超过msl
如果连2个msl都超过,但是没有收到中间对端的fin ack,可以认为:
- 对端收到了最后的ack,对端已经成功close
- 当前网络gg


### 一些非常规情况
#### 握手过程cli没有收到svr的ack
内核会有超时时间,或者应用在SYN_SENT状态关闭了连接:cli**转为close状态**.此时的fd会有errno是**ECONNRESET**
可以认为当前的请求连接失败,进入关闭状态,后续重新连接.
```ditaa
┌─────────────┐ │                                                  │ ┌─────────────┐
│             │ │                                                  │ │   CLOSED    │
│   CLOSED    │cli                                                svr├─────────────┤
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
├─────────────┤ ╳                                                  │ │   LISTEN    │
│             │ │╲                                                 │ │             │
│             │ │ ╲─────────────────────SYN 500(0)────────────────╲│ │             │
│             │ │                                                  ▼ │             │
│             │ │                                                  │ └─────────────┘
│             │ │                                                  │                
│  SYN_SENT   │ │                                                  │                
│             │ │                                                  │                
│             │ │                                                  │                
│             │ │                                                  │                
│             │ │                                                  │                
│             │ │                                                  │                
╠═════════════╣ │                                                  │                
║             ║ │                                                  │                
║   CLOSED    ║ │                                                  │                
║             ║ │                                                  │                
╚═════════════╝ │                                                  │                
                ▼                                                  ▼                
```
#### SENT状态时候收到的不是SYN ACK 而是SYN
说明对端也在请求连接.这里会进入SYN_RCVD,等待对端的ack然后进入ESTABLISHED
可以认为是对端也在请求连接,所以需要发出确认信号(同时发syn ack).因为**此时对端已经有意向和本端连接**,所以没必要再次发送一次请求对端和本端连接的请求.收到对端的ack,可以认为对端已经确认了本端意向的通信.能成功拿到对端的syn ack就可以认为:
- 已经回复对端同意建立对端的连接请求
- 本端的连接请求对端已经同意连接

因此进入establish状态.
```ditaa
┌─────────────┐ │                                                  │ ┌─────────────┐
│             │ │                                                  │ │             │
│   CLOSED    │cli                                                svr│   CLOSED    │
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
├─────────────┤ ╳                                                  ╳ ├─────────────┤
│             │ │╲                                                ╱│ │             │
│             │ │ ╲─────────────────────SYN 500(0)───────────────╳ │ │  SYN_SENT   │
│             │ │                                               ╱ ╲│ │             │
│             │ │                                              ╱   ▼ │             │
│  SYN_SENT   │ │   ╱─────────────────SYN 700(0)──────────────╱    ╳ ├─────────────┤
│             │ │  ╱                                              ╱│ │             │
│             │ │ ╱                                              ╱ │ │             │
│             │ │╱                                              ╱  │ │             │
│             │ ▼                                              ╱   │ │             │
├─────────────┤ ╳                                             ╱    │ │  SYN_RCVD   │
│             │ │╲   ╱────────SYN 700(0) ACK 501─────────────╱     │ │             │
│             │ │ ╲ ╱                                              │ │             │
│  SYN_RCVD   │ │  ╳───────────SYN 500(0) ACK 701───────────────╲  │ │             │
│             │ │ ╱                                              ╲ │ │             │
│             │ │╱                                                ╲│ │             │
├─────────────┤ ▼                                                  ▼ ├─────────────┤
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
│ ESTABLISHED │ │                                                  │ │ ESTABLISHED │
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
│             │ │                                                  │ │             │
└─────────────┘ │                                                  │ └─────────────┘
                │                                                  │                
                │                                                  │                
                │                                                  │                
                │                                                  ▼                
                ▼                                                                   
```
#### SYN_RCVD之后对端没有发ack回应请求建立
这里有两种情况:
1.svr建立连接的时候收到cli的syn,返回了ack并且请求和cli建立连接(syn)但是没有得到回应(没有收到ack).内核会在超时后把状态流转为LISTEN//TODO 具体机制
2.svr在syn_rcvd时候收到了RST请求
会转到LISTEN,重新监听端口.
可以理解为:
本端同意了对端的连接,但是对端迟迟没有答复.这种可能对端gg了也可能网络gg了,继续监听.
如果收到了RST,就是对端要求重新连接.

#### 关闭时候对端也发送了FIN请求
同时关闭

1.对端发送的是fin请求
可以理解:
- 本端有意向请求对端关闭
- 本端知道对端有意向和本端关闭
- 本端回包ack,表示本端同意关闭
- 本端等待对端ack,如果收到,对端答应了本端的关闭
- 收到对端ack后进入TIME_WAIT,是因为收到对端ack能确认的是本端的关闭连接对端已经确认(也就是本端不在给对端传送数据),但是本端给对端的ack(也就是本端同意对端不再连接本端)的确认信息对端不一定会拿到.等待TIME_WAIT防止对端可能没有收到本端的ack,可能重新发包告知请求fin.
  
```ditaa
                                                                   │  ┌─────────────┐
┌─────────────┐ │                                                  │  │             │
│             │ │                                                  │  │             │
│ ESTABLISHED │ cli                                                │  │             │
│             │ │                                                svr  │ ESTABLISHED │
│             │ │                                                  │  │             │
├─────────────┤ ╳                                                  │  │             │
│             │ │╲                                                 │  │             │
│             │ │ ╲                                                │  │             │
│             │ │  ╲                                               ╳  ├─────────────┤
│             │ │   ╲                                             ╱│  │             │
│             │ │    ╲                                           ╱ │  │             │
│ FIN_WAIT_1  │ │     ╲                                         ╱  │  │             │
│             │ │   ╱──╳──────────────FIN, 8011(0)─────────────╱   │  │             │
│             │ │  ╱    ╲                                          │  │             │
│             │ │ ╱      ╲─────FIN,1021(0)────────────────╲        │  │             │
│             │ │╱                                         ╲       │  │             │
│             │ ▼                                           ╲      │  │ FIN_WAIT_1  │
╠═════════════╣ ╳                                            ╲     │  │             │
║             ║ │╲                                            ╲    │  │             │
║             ║ │ ╲                                            ╲   │  │             │
║             ║ │  ╲                                            ╲  │  │             │
║             ║ │   ╲                                            ╲ │  │             │
║             ║ │    ╲                                            ╲│  │             │
║   CLOSING   ║ │     ╲                                            ▼  │             │
║             ║ │      ╲──────ACK 8012──────────────────────╲      ╳  ╠═════════════╣
║             ║ │                                            ╲    ╱│  ║             ║
║             ║ │                                             ╲  ╱ │  ║             ║
║             ║ │  ╱───────────ACK 1022────────────────────────╳╱  │  ║   CLOSING   ║
║             ║ │ ╱                                             ╲  │  ║             ║
║             ║ │╱                                               ╲ │  ║             ║
╠═════════════╣ ▼                                                 ╲│  ║             ║
║             ║ │                                                  ▼  ╠═════════════╣
║             ║ │                                                  │  ║             ║
║             ║ │                                                  │  ║             ║
║             ║ │                                                  │  ║             ║
║  TIME_WAIT  ║ │                                                  │  ║             ║
║             ║ │                                                  │  ║  TIME_WAIT  ║
║             ║ │                                                  │  ║             ║
║             ║ │                                                  │  ║             ║
║             ║ │                                                  │  ║             ║
╚═════════════╝ │                                                  │  ║             ║
                ▼                                                  ▼  ╚═════════════╝
```

2.对端发送的是fin ack请求
可以理解为三次松手.
这个时候可以理解为四次松手的特殊情况,svr没有CLOSE_WAIT等待直接跳过,发送FIN,进入LASK_ACK
```ditaa
┌─────────────┐                                                                     
│             │                                                    │                
│             │ │                                                  │ ┌─────────────┐
│ ESTABLISHED │ │                                                  │ │             │
│             │ │ cli                                            svr │             │
│             │ │                                                  │ │             │
├─────────────┤ ╳                                                  │ │ ESTABLISHED │
│             │ │╲                                                 │ │             │
│             │ │ ╲────────FIN,1021(0),ACK8011────────────────────╲│ │             │
│             │ │                                                  ▼ │             │
│ FIN_WAIT_1  │ │                                                  ╳ ╠═════════════╣
│             │ │                                                 ╱│ ║             ║
│             │ │ ╱─────────FIN, 8011() ACK 1022─────────────────╱ │ ║             ║
│             │ │╱                                                 │ ║             ║
│             │ ▼                                                  │ ║  LAST_ACK   ║
╠═════════════╣ ╳                                                  │ ║             ║
║             ║ │╲                                                 │ ║             ║
║             ║ │ ╲───────────────────ACK 8012───────────────────╲ │ ║             ║
║             ║ │                                                 ╲│ ║             ║
║             ║ │                                                  ▼ ╠─────────────╣
║  TIME_WAIT  ║ │                                                  │ │             │
║             ║ │                                                  │ │   CLOSED    │
║             ║ │                                                  │ │             │
║             ║ │                                                  │ │             │
║             ║ │                                                  │ └─────────────┘
╠─────────────╣ │                                                  │                
│             │ │                                                  │                
│   CLOSED    │ │                                                  │                
│             │ │                                                  │                
│             │ │                                                  │                
└─────────────┘ │                                                  │                
                ▼                                                  ▼                
```





### tcp状态转移图
![](../imgs/network/tcp_state_transition.png)

#### SYN_RCVD
服务端在发送SYN之后超时,会给cli发送RST,**防止泛洪攻击**

#### 状态描述
- SYN_SENT:不会重传.如果cli进行close或者超时会返回到CLOSED状态
- SYN_RCVD:请求放入**未完成队列**,是backlog参数的大小
    - 如果超时还没有收到对端的SYN:根据`/proc/sys/net/ipv4/tcp_synack_retries`决定重发次数.如果超过重发次数会发送RST消息,进入CLOSE状态.
    - 如果接收到RST返回到LISTEN状态.
    - 如果调用了close会发送FIN消息并且进入FIN_WAIT_1
    - 如果收到ACK,进入ESTABLISHED,并且请求从**未完成队列**放入到**已完成队列**,由内核交给程序控制
        - 如果已完成队列已满,当服务器收到ACK请求:
            - 如果` /proc/sys/net/ipv4/tcp_abort_on_overflow`设置为1,返回RST
            - 如果没有设置,忽略ACK包
            - 如果启用syncookies (net.ipv4.tcp_syncookies = 1),新的连接不进入未完成队列,不受影响.好处是可以让cli继续发送.是防止**泛洪攻击**的有效手段
        - 内核定时看未完成队列.如果网络原因没有收到ACK或者收到ACK忽略了,最大的重试次数是`/proc/sys/net/ipv4/tcp_synack_retries`
- FIN-WAIT-1:超时重传
- CLOSE-WAIT:超时重传
- FIN-WAIT-2:超时重传

### 2MSL
端口复用
time_wait时候占用端口.只能通过复用的方法再用这个端口.否则绑定失败.
setsockopt能设置端口复用.
- optname SO_REUSEADDR
- optname SO_REUSEPORT

setsockopt(lfd,SOL_SOCKET,SO_REUSEADDR,(void *)&opt,sizeof(opt));
注意:需要在**绑定前**设置

//TODO test code

### 半关闭
shutdown(int  sockfd, int how)
- sockfd sfd
- how
    - SHUT_RD 读关闭 读缓存关闭
    - SHUT_WR 写关闭 写缓存关闭
    - SHUT_RDWR读写关闭

close和shutdown区别:
close无法精准关闭,只是关闭了fd.
简单文件操作,dup2(3,4)之后,close(3)还可以用4进行文件操作.
但是对于sock fd, 不管之前怎么dup,只要其中的sfd被shutdown,其他dup过去的fd都不能做对应的操作.所有指向socket fd的dentry都会关掉.
对比close,close只会是到了所有指向dentry的fd都关闭才会关闭.而shutdown会直接把这些fd都关闭-->**全关闭**

总结:
- 多个进程共享一个socket,close没调用1次,计数-1.直到计数为0,所有进程都close,socket被释放.
- 多个进程如果其中一个进程调用了shutdown,其他进程无法通信,因为使用的是**全关闭**的方法.但如果仅仅是close,其他进程不受影响.

# UDP
无连接的不可靠的数据报传输 丢包补重传.
TCP 面向连接的可靠数据报传输 丢包重传弥补网络不稳定,是可靠的,丢包不弥补.

||TCP|UDP|
|---|---|---|
|特性|面向连接,可靠数据报传输.对于不稳定网络层采用完全弥补的通信机制,丢包重传|无连接,不可靠的数据报传输.对于不稳定的网络层采取完全不弥补的通信方式.默认还原网络状况.|
|优点|稳定.数据流量稳定,速度稳定.顺序|传输速度快,效率高,开销小|
|缺点|传输速度慢,速率低,开销大|不稳定.数据流量不稳定,乱序,速度不稳定|
|场景|数据完整性要求较高,不追求速率.大型文件传输,大数据传输|时效性要求高,稳定性其次.视频,游戏,视频会议,电话会议|

使用UDP通信在应用层添加校验协议,弥补udp不足

UDP实现的cs模型
不需要accept connect
server
socket : SOCK_DGRAM
bind
listen(可无)
recvfrom sendto

client
socket : SOCK_DGRAM
bind
connect(cfd,addr,)
recvfrom sendto(服务器addr)
注意:client在使用sendto的是偶绑定服务器socket的端口并没有什么用,最终根据sendto的时候addr里面的sin_port发送.
sendto 相当于connect了

## 大小端
字符串数据在大小端不同的CPU之间传输时，可以不用转换，因为字符串是按字节排序的32位处理器的话，以4字节为单位进行大小端转换的  
int类型的需要hton,因为并不会转换.如果异构系统读取,可能gg