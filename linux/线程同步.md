# 线程同步


## 线程同步概念

### 协同步调,按预定先后次序执行

### 与时间有关的错误

### 数据混乱

- 资源共享

- 随机调度

- 缺乏必要的同步机制

### 多个控制流访问同一共享资源,必须同步

## 互斥量(互斥锁)

### mutex

- 建议锁

- 锁,不会限制资源访问

- 线程不按规则访问数据依然成功,但是会出现数据混乱

### 函数

- pthread_mutex_t类型

	- 本质:结构体

	- 简化:1,0

- 返回值:

	- 成功

		- 0

	- 失败

		- errno

- pthread_mutex_init

	- 初始化一把互斥锁

		- 1

	- 参数

		- 互斥锁mutex(传出)

		- 互斥锁属性(传入)

			- 默认属性NULL

		- restrict关键字

			- 所有修改该指针指向内存内容的操作,只能通过本指针完成

	- 适合放在函数内使用

- 静态初始化

	- PTHREAD_MUTEX_INITIALIZER

	- 适合放在全局变量使用

- pthread_mutex_destroy

	- 销毁一个互斥锁

	- 参数

		- &mutex

- pthread_mutex_lock

	- 加锁

	- 参数

		- &mutex

	- mutex - -

	- 减为0之后再加锁:阻塞

- pthread_mutex_unlock

	- 解锁

	- 参数

		- &mutex

	- mutex++

	- 同时将阻塞在该锁的所有线程唤醒

- pthread_mutex_trylock

	- 非阻塞加锁

	- 参数

		- &mutex

	- mutex++

- 锁的”粒度”(临界区)

	- 越小越好

	- 访问公共资源之前加锁,访问后立即解锁

## 死锁

### 产生原因

- 对同一个互斥量反复加锁

- A锁1后锁2,B锁2后锁1

### 避免方法

- 保证资源获取顺序,每个资源对锁的获取顺序一致

- 得不到更多需要资源时候放弃锁,等待

## 读写锁

### 使用要领

- 读共享,写独占

- 写锁优先级高,一起等待的话写锁线程先被唤醒

### 状态

- 读模式下加锁  读锁

- 写模式下加锁  写锁

- 不加锁状态

### 特性

- 写模式加锁

	- 解锁前,所有对该所加锁的线程都会阻塞

- 读模式加锁

	- 线程以写模式加锁,阻塞

	- 线程以多模式加锁,成功

- 写锁读锁同时阻塞:锁释放后优先满足写锁

### 使用场景

- 适合对数据结构读次数大于写

### 函数

- pthread_rwlock_t

- 返回

	- 成功

		- 0

	- 失败

		- errno

- 参数

	- 都是 &rwlock

- pthread_rwlock_init

	- 参数

		- &rwlock

		- 属性attr (NULL)

- pthread_rwlock_destroy

- pthread_rwlock_rdlock

- pthread_rwlock_wrlock

- pthread_rwlock_tryrdlock

- pthread_rwlock_trywrlock

- pthread_rwlock_unlock

## 条件变量

### 特性

- 不是锁

- 可以造成线程阻塞

- 与mutex配合使用

### 函数

- pthread_cond_t

- 返回

	- 成功

		- 0

	- 失败

		- errno

- pthread_cond_init

	- 参数

		- &cond

		- 属性attr (NULL)

- pthread_cond_destroy

- pthread_cond_wait

	- 阻塞等待一个条件变量

	- 参数

		- &cond

		- &mutex

	- 作用

		- 1.释放已经掌握的mutex

		- 2.阻塞等待条件变量

		- 3.被唤醒时候重新获取互斥锁

		- 1.2.是原子操作

- pthread_cond_timewait

	- 参数3

		- abstime

			- 绝对时间

			- struct timespec

				- tv_sec 秒

				- tv_usec 微妙

			- 使用方法

				- time_t cur = time(NULL)

				- struct timespec t

				- pthread_cond_timewait(...)

- pthread_cond_signal

	- 唤醒(至少)一条阻塞在条件变量上的线程

- pthread_cond_breadcast

	- 唤醒全部阻塞在条件变量上的线程

	- 尽量少用,手动惊群

### 生产者消费者模型

### 有点:减少不必要的竞争

## 信号量

### sem

- 进化版互斥锁(1->N)

- 保证同步同时,提高并发

- 多个线程进入共享区需要保证访问处理不混乱,要指定访问先后顺序

- 支持进程,需要放shm

### 函数

- sem_t

	- 本质结构体

	- N表示线程数量

	- N不能<0

	- #include <semaphore.h>

- sem_init

	- 参数

		- &sem

		- 是否在进程间共享

			- 非0进程间(PTHREAD_PROCSS_SHARED)

			- 0线程间(PTHREAD_PROCESS_PRIVATE)

		- N线程数

- sem_destroy

- sem_wait

	- 给信号量加锁

		- sem - - lock

- sem_trywait

- sem_timewait

- sem_post

	- 给信号量解锁 sem ++ unlock

	- 唤醒阻塞在信号量上的线程

### 生产者消费者模型



# 线程同步
多个线程访问同一个数据的时候是一致的.要对数据的感知一致.

在线程1对公共数据a进行处理的时候,需要完整处理完后才能让其他线程处理.

线程同步的锁都是**建议锁**,也就是说锁不锁是线程逻辑控制的事情,不会让线程不能访问共享区域的数据.
- 不按照同步规则能访问数据
- 不按照同步规则不保证数据一致

前提:所有处理数据的线程都要用同步机制(锁)

## mutex
#### 函数
- pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
- pthread_mutex_destroy(pthread_mutex_t *mutex);
- pthread_mutex_lock(pthread_mutex_t *mutex);  阻塞进行获取锁
- pthread_mutex_trylock(pthread_mutex_t *mutex) 不阻塞进行获取锁 失败返回EBUSY,锁忙
- pthread_mutex_unlock(pthread_mutex_t *mutex)

pthread_mutex_t 本质是结构体,是现实可以当成整数看待
pthread_mutex mutex变量:只有两种取值:0 1
**注意**`pthread_mutex_init`使用`restrict`修饰符,表示该指针指定的内存区域只能由**本指针**访问.其他同类型的指针不能访问.用于限定指针变量.

操作的时候注意:
while(1){
    [加锁]
    [操作]
    [解锁]
    [**此处应该预留适当的时间空隙交出锁,防止线程占用锁过多**,因为这里下面就是加锁]   
}

可以认为:
初始化后锁值为1.
加锁  -- 加锁失败:阻塞
解锁 ++ 成功:唤醒其他阻塞在锁上的线程
如果<=0,不能再减
try锁:尝试加锁,成功-- 失败不变

注意事项
- 保证锁的粒度越小越好(访问前才加锁,访问后立即解锁)

## 读写锁
写模式加锁,解锁前所有对锁加锁的线程都阻塞
读模式加锁,线程读模式加锁成功,写模式加锁阻塞
读模式加锁,阻塞的读模式加锁和写模式加锁会**优先满足写模式解加锁**


总结阻塞情况

|加锁类型|读模式已锁|写模式已锁|
|----|----|----|
|读模式加锁|成功|阻塞|
|写模式加锁|阻塞|阻塞|


#### 函数
- int pthread_rwlock_destroy(pthread_rwlock_t *rwlock)
- int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
- int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
- int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
- int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
- int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
- int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

解锁只有一个unlock 但是加锁有读或者写锁

对比互斥量而言,读线程多的时候提高访问效率
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>

int counter;
pthread_rwlock_t rwlock;
void *th_w(void *arg){
    int t;
    long int i = (long int) arg;
    while(1){
        pthread_rwlock_wrlock(&rwlock);
        t = counter;
        usleep(1000);
        printf("==%ldth thread|write:%d|tid=%lu|++counter=%d\n",i, t, pthread_self(), ++counter);
        pthread_rwlock_unlock(&rwlock);
        usleep(2);//设置太长,子线程都排满了,读优先导致总是读.设置太短,怕线程自己拿回锁.``
    }
    return NULL;
}
void *th_r(void *arg){
    int t;
    long int i = (long int) arg;
    while(1){
        pthread_rwlock_rdlock(&rwlock);
        t = counter;
        usleep(1000);
        printf("==%ldth thread|read:%d|tid=%lu====\n",i, t, pthread_self() );
        pthread_rwlock_unlock(&rwlock);
        usleep(2);
    }
    return NULL;
}

void sys_err(const char* str){
    perror(str);
    exit(1);
}

int main(int argc, char* argv[])
{
    pthread_t tid[8];
    pthread_rwlock_init(&rwlock, NULL);
    int i = 0;
    for(i = 0; i < 2; i++){
        pthread_create(&tid[i],NULL, th_w, (void*)i);
    }
    for(i = 0; i < 6; i++){
        pthread_create(&tid[2+i],NULL, th_r, (void*)i);
    }
    for(i = 0;i < 8; i++){
        pthread_join(tid[i], NULL);
    }
    pthread_rwlock_destroy(&rwlock);
    pthread_exit((void*)0);

}

```
结果:
```
==0th thread|write:822|tid=139771779868416|++counter=823
==1th thread|write:823|tid=139771771475712|++counter=824
==1th thread|write:824|tid=139771771475712|++counter=825
==0th thread|write:825|tid=139771779868416|++counter=826
==1th thread|write:826|tid=139771771475712|++counter=827
==0th thread|write:827|tid=139771779868416|++counter=828
==1th thread|write:828|tid=139771771475712|++counter=829
==0th thread|write:829|tid=139771779868416|++counter=830
==1th thread|write:830|tid=139771771475712|++counter=831
==0th thread|write:831|tid=139771779868416|++counter=832
==1th thread|write:832|tid=139771771475712|++counter=833
==0th thread|write:833|tid=139771779868416|++counter=834
==1th thread|write:834|tid=139771771475712|++counter=835
==0th thread|write:835|tid=139771779868416|++counter=836
==1th thread|write:836|tid=139771771475712|++counter=837
==0th thread|write:837|tid=139771779868416|++counter=838
==1th thread|write:838|tid=139771771475712|++counter=839
==0th thread|write:839|tid=139771779868416|++counter=840
==1th thread|write:840|tid=139771771475712|++counter=841
==0th thread|write:841|tid=139771779868416|++counter=842
==1th thread|write:842|tid=139771771475712|++counter=843
==5th thread|read:843|tid=139771721119488====
==2th thread|read:843|tid=139771746297600====
==4th thread|read:843|tid=139771729512192====
==3th thread|read:843|tid=139771737904896====
==1th thread|read:843|tid=139771754690304====
==0th thread|read:843|tid=139771763083008====
==5th thread|read:843|tid=139771721119488====
==4th thread|read:843|tid=139771729512192====
==0th thread|read:843|tid=139771763083008====
==2th thread|read:843|tid=139771746297600====
==3th thread|read:843|tid=139771737904896====
==1th thread|read:843|tid=139771754690304====
==5th thread|read:843|tid=139771721119488====
==0th thread|read:843|tid=139771763083008====
==4th thread|read:843|tid=139771729512192====
==2th thread|read:843|tid=139771746297600====
==3th thread|read:843|tid=139771737904896====
==1th thread|read:843|tid=139771754690304====
==5th thread|read:843|tid=139771721119488====
==4th thread|read:843|tid=139771729512192====
```
可以看到是片区的读和片区的写.
这里分片的原因是:
- 多个线程等待读写锁的时候,总是写锁优先可以加上锁.所以写会一起
- 读拿到之后因为很多线程都在读,所以读一旦拿到 会很多读线程先读了,读完之后到了写线程能排上队,才能写.
  
如果调整写锁在解锁后的睡眠情况(例如2s),就看到读多写少的情况.

# 死锁
是一种现象
保证对资源的加锁顺序一致可以保证不会死锁
常见现象:
- 对一个锁反复lock
- 加锁顺序不一致

对一个锁反复lock
```ditaa
             1.lock                 
     ┌────────succ────────────┐     
     │                        │     
     │                        ▼     
┌────────┐    2.lock     ┌─────────┐
│ thread │────again─────▶│  lock   │
└────────┘  ->blocked    └─────────┘
                          ┌────────┐
                          │        │
                          │        │
                          │resource│
                          │        │
                          │        │
                          └────────┘
```
加锁顺序不一致
```ditaa
                                                                
     ┌─1.lock lock1 succ───────┐                                
     │                         │                                
     │                         ▼                                
     │                    ┌─────────┐      2.lock lock1         
     │                    │  lock1  │◀──────-->blocked─────┐    
     │                    └─────────┘                      │    
┌────────┐                                            ┌────────┐
│thread1 │                                            │thread2 │
└────────┘                 ┌─────────┐                └────────┘
     │            ┌───────▶│  lock2  │                     │    
     │     2.lock lock2    └─────────┘                     │    
     └──────-->blocked          ▲                          │    
                                │                          │    
                                └─────1.lock lock2 succ────┘    
                                                                
```

## 条件变量
本身**不是锁**,通常结合锁使用 mutex
会等待某个条件满足.

- int pthread_cond_destroy(pthread_cond_t *cond);
- int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);
> - int pthread_cond_init初始化:动态初始化.在哪里用到再初始化
> -  pthread_cond_t cond = PTHREAD_COND_INITIALIZER 静态初始化.代替了上述的函数,拿到一个初始化的cond. mutex特有这样的静态初始化.
- int pthread_cond_timedwait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex,
- const struct timespec *restrict abstime);
- int pthread_cond_wait(pthread_cond_t *restrict cond,pthread_mutex_t *restrict mutex);//阻塞,等待条件满足. 调用wait只能和mutex一起使用.
> - 阻塞等待条件变量cond
> - 释放已经掌握的互斥锁 相当于pthread_mutex_unlock(&mutex)
> - 上述两步是原子操作
> - 当被唤醒(pthread_cond_wait返回)时,解除屏蔽并重新申请获取互斥锁(重新加锁) pthread_mutex_unlock(&mutex)
- int pthread_cond_broadcast(pthread_cond_t *cond);//一次通知一堆
- int pthread_cond_signal(pthread_cond_t *cond); //一次通知一个

wait
```ditaa
┌────────────────────────────────────────────────────────────────────────────────┐
│                                                                                │
│                                                                                │
│  ┌───────────────────┐                               ┌───────────────────┐     │
│  │   wait for cond   ├────────block─────────────────▶│    cond comes     │     │
│  └───────────────────┘                               └───────────────────┘     │
│                                                                                │
│                                                                                │
│  ┌────────────────────┐                              ┌────────────────────┐    │
│  │ unlock mutex,block │                              │ unblock,lock mutex │    │
│  └────────────────────┘                              └────────────────────┘    │
│                                                                                │
│                                                                                │
└────────────────────────────────────────────────────────────────────────────────┘
```
可以看到,wait的时候先unlock了mutex,然后阻塞等待.
通过signal或者broadcast来唤醒.
返回的时候,阻塞解除,然后锁了.

有点像通过mutex加锁阻塞.

生产者&消费者模型
```ditaa
                                              │                                                                    
                                         0.init cond                                                               
                                         lock mutex                                                                
                                              │                                                                    
                                   ┌──────────▼──────────┐                                                         
  p4.cond_signal/cond_broadcast    │  ┌───────────────┐  │      c2.cond_wait(release mutex and block) 
     ┌─────unlock cond─────────────┼─▶│  conditon 1   │◀─┼────────────────c4.cond_signal/cond_broadcast            
     │                             │  └───────────────┘  │                         unlock cond                     
     │                             │                     │                                  │                      
     │                             │                     │                                  │                      
     │      p1.lock mutex for      │  ┌───────────────┐  │     c1.lock mutex                │                      
     ├───────access resource───────┼─▶│     mutex     │◀─┼────c5.unlock mutex───────────────┤                      
     │       p3.unlock mutex       │  └───────────────┘  │                                  │                      
     │                             └──────────┬──────────┘                                  │                      
     │                                        │                                             │                      
     │                                        │                                             │                      
     │                           mutex locks public resource                                │                      
     │                                        │                                             │                      
     │                                        ▼                                             │                      
     │                                ┌───────────────┐                                     │                      
     │                                │               │                                     │                      
     │                                │               │                                     │                      
┌─────────┐                           │               │                                ┌─────────┐                 
│producer │──p2. satisfy condition───▶│public resource│◀──────c3.access resource───────│consumer │                 
└─────────┘                           │               │                                └─────────┘                 
                                      │               │                                                            
                                      │               │                                                            
                                      └───────────────┘                                                                                                                                                                            
```
可以理解成:
- 条件锁的是条件,mutex锁的是资源
- mutex被解锁,如果cond不满足,wait也是失败. mutex如果已经锁了 wait是否成功?//TODO
- 对资源的访问都要进行解锁才能操作.
- 进入公共资源之前都需要进行加锁,处理之后都要解锁
- **wait的时候会先解锁**,因此在**wait的时候其他线程是可以进入公共区域进行操作的**

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>

struct msg{
    struct msg* next;
    int num;
};
void sys_err(const char* str){
    perror(str);
    exit(1);
}

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond= PTHREAD_COND_INITIALIZER;
struct msg* head;

void *consumer(void *p){
    struct msg* tmp;
    printf("in consumer\n");
    while(1){
        pthread_mutex_lock(&mutex);
        while(head == NULL){
            pthread_cond_wait(&cond, &mutex);//如果注释了,死锁,producer因为lock不到死锁
        }
        printf("consumer get node.val=%d\n", head->num);
        tmp = head;
        head = tmp->next;
        free(tmp);
        pthread_mutex_unlock(&mutex);
        sleep(rand()%3);
    }
    return NULL;
}

void *porducer(void *p){
    printf("in producer\n");
    struct msg* tmp;
    int i = 0;
    while(1){
        pthread_mutex_lock(&mutex);
        tmp = head;
        struct msg *m;
        m = (struct msg*) malloc(sizeof(struct msg));
        m->next = head;
        i++;
        m->num = i;
        head = m;
        printf("producer add node value = %d\n", head->num);
        pthread_mutex_unlock(&mutex);
        pthread_cond_broadcast(&cond);
        sleep(rand()%3);
    }
    return NULL;
}
int main(int argc, char* argv[])
{
    pthread_t tc,tp;
    pthread_create(&tc, NULL, consumer,NULL);
    sleep(1);
    pthread_create(&tp, NULL, porducer,NULL);

    pthread_join(tc, NULL);
    pthread_join(tp,NULL);
    return 0;
}
```
结果
```
➜  thread ./cond
in consumer
in producer
producer add node value = 1
consumer get node.val=1
producer add node value = 2
producer add node value = 3
consumer get node.val=3
producer add node value = 4
```
能看到,consumer线程虽然在循环里lock了mutex,但是因为在head == null的时候,wait的时候会先解锁然后等待.在这个间隙producer可以插入并通知.

多个consumer
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>

struct msg{
    struct msg* next;
    int num;
};
void sys_err(const char* str){
    perror(str);
    exit(1);
}

pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond= PTHREAD_COND_INITIALIZER;
struct msg* head;

void *consumer(void *p){
    long int i = (long int)p;
    struct msg* tmp;
    printf("in consumer\n");
    while(1){
        pthread_mutex_lock(&mutex);
        while(head == NULL){
            pthread_cond_wait(&cond, &mutex);
        }
        printf("consumer %ld get node.val=%d\n",i, head->num);
        tmp = head;
        head = tmp->next;
        free(tmp);
        pthread_mutex_unlock(&mutex);
        sleep(rand()%3);
    }
    return NULL;
}

void *porducer(void *p){
    printf("in producer\n");
    struct msg* tmp;
    int i = 0;
    while(1){
        pthread_mutex_lock(&mutex);
        tmp = head;
        struct msg *m;
        m = (struct msg*) malloc(sizeof(struct msg));
        m->next = head;
        i++;
        m->num = i;
        head = m;
        printf("producer add node value = %d\n", head->num);
        pthread_mutex_unlock(&mutex);
        pthread_cond_broadcast(&cond);
        sleep(rand()%3);
    }
    return NULL;
}
int main(int argc, char* argv[])
{
    pthread_t tc,tp;
    pthread_create(&tc, NULL, consumer,(void*)1);
    sleep(1);
    pthread_create(&tc, NULL, consumer,(void*)2);
    sleep(1);
    pthread_create(&tp, NULL, porducer,NULL);

    pthread_join(tc, NULL);
    pthread_join(tp,NULL);
    return 0;
}
```
结果
```
➜  thread ./cond
in consumer
in consumer
in producer
producer add node value = 1
consumer 1 get node.val=1
producer add node value = 2
producer add node value = 3
consumer 1 get node.val=3
consumer 2 get node.val=2
producer add node value = 4
consumer 2 get node.val=4
```
多个consumer的时候,阻塞在在cond.
同时被唤醒的时候,因为wait成功的会把mutex抢走,所以wait成功的线程是成功锁了mutex的.

#### 多消费者竞争机制
cond_wait注意点:
- cond_wait在阻塞之前会先把mutex释放
- 阻塞如果成功,会把mutex重新锁上
- 如果锁不上mutex,这时候cond_wait已经不是阻塞在cond上,是阻塞在mutex的锁里.只有锁成功了,才能成功返回.否则继续阻塞.
图解
1.consumer初始化,对mutex上锁
```ditaa
                                       │                                                              
                                       │                                                              
                                      0│                                                              
                                       │                                                              
                            ┌──────────▼──────────┐                                        ┌─────────┐
                            │  ┌───────────────┐  │                                        │consumer2│
                            │  │  conditon ■   │  │                                        └─────────┘
                            │  └───────────────┘  │                                                   
                            │                     │                                                   
                            │                     │                                                   
                            │  ┌───────────────┐  │                                                   
                            │  │    mutex ◼    │◀─┼────1.lock─────────────────┐                       
                            │  └───────────────┘  │                           │                       
                            └──────────┬──────────┘                           │                       
                                       │                                      │                       
                                       │                                      │                       
                                       │                                      │                       
                                       │                                      │                       
                                       ▼                                 ┌─────────┐                  
┌─────────┐                    ┌───────────────┐                         │consumer1│                  
│producer │                    │               │                         └─────────┘                  
└─────────┘                    │               │                                                      
                               │               │                                                      
                               │public resource│                                                      
                               │               │                                                      
                               │               │                                                      
                               │               │                                                      
                               └───────────────┘                                                      
```
2.consumer进行cond_wait
```ditaa
                            ┌─────────────────────┐                                        ┌─────────┐
                            │  ┌───────────────┐  │                                        │consumer2│
                            │  │  conditon ■   │◀─┼─────2.2.cond_wait─────────┐            └─────────┘
                            │  └───────────────┘  │                           │                       
                            │                     │                           │                       
                            │                     │                           │                       
                            │  ┌───────────────┐  │                           │                       
                            │  │    mutex □    │◀─┼─2.1.cond_wait(unlock mutex│                       
                            │  └───────────────┘  │                           │                       
                            └──────────┬──────────┘                           │                       
                                       │                                      │                       
                                       │                                      │                       
                                       │                                      │                       
                                       │                                      │                       
                                       ▼                                 ┌─────────┐                  
┌─────────┐                    ┌───────────────┐                         │consumer1│                  
│producer │                    │               │                         └─────────┘                  
└─────────┘                    │               │                                                      
                               │               │                                                      
                               │public resource│                                                      
                               │               │                                                      
                               │               │                                                      
                               │               │                                                      
                               └───────────────┘                                                      
```
3.consumer进行mutex lock
```ditaa
                                                                                        ┌─────────┐
                                                                                        │consumer2│
                            ┌─────────────────────┐                                     └─────────┘
                            │  ┌───────────────┐  │                                          │     
                            │  │  conditon ■   │◀─┼────────cond_wait──────────┐              │     
                            │  └───────────────┘  │                           │              │     
                            │                     │                           │              │     
                            │                     │                           │              │     
                            │  ┌───────────────┐  │                           │              │     
                            │  │    mutex ■    │◀─┼──────────1.lock───────────┼──────────────┘     
                            │  └───────────────┘  │                           │                    
                            └──────────┬──────────┘                           │                    
                                       │                                      │                    
                                       │                                      │                    
                                       │                                      │                    
                                       │                                      │                    
                                       ▼                                 ┌─────────┐               
┌─────────┐                    ┌───────────────┐                         │consumer1│               
│producer │                    │               │                         └─────────┘               
└─────────┘                    │               │                                                   
                               │               │                                                   
                               │public resource│                                                   
                               │               │                                                   
                               │               │                                                   
                               │               │                                                   
                               └───────────────┘                                                   
```
4.consumer2 cond_wait
```ditaa
                                                                                   ┌─────────┐               
                                       ┌─────────────────────2.2.cond_wait─────────│consumer2│               
                                       │                                           └─────────┘               
                                       │                                                │                    
                            ┌──────────▼──────────┐                                     │                    
                            │  ┌───────────────┐  │                        2.1.cond_wait.release mutex       
                            │  │  conditon ■   │◀─┼───────cond_wait───────────┐         │                    
                            │  └───────────────┘  │                           │         │                    
                            │                     │                           │         │                    
                            │                     │                           │         │                    
                            │  ┌───────────────┐  │                           │         │                    
                            │  │    mutex □    │◀─┼───────────────────────────┼─────────┘                    
                            │  └───────────────┘  │                           │                              
                            └──────────┬──────────┘                           │                              
                                       │                                      │                              
                                       │                                      │                              
                                       │                                      │                              
                                       │                                      │                              
                                       ▼                                 ┌─────────┐                         
┌─────────┐                    ┌───────────────┐                         │consumer1│                         
│producer │                    │               │                         └─────────┘                         
└─────────┘                    │               │                                                             
                               │               │                                                             
                               │public resource│                                                             
                               │               │                                                             
                               │               │                                                             
                               │               │                                                             
                               └───────────────┘                                                             
```
5.producer lock mutex for access
```ditaa
                                                                                   ┌─────────┐
                                       ┌───────────────────────cond_wait───────────│consumer2│
                                       │                                           └─────────┘
                                       │                                                      
                            ┌──────────▼──────────┐                                           
                            │  ┌───────────────┐  │                                           
                            │  │  conditon ■   │◀─┼───────cond_wait───────────┐               
                            │  └───────────────┘  │                           │               
                            │                     │                           │               
                            │                     │                           │               
                            │  ┌───────────────┐  │                           │               
                    ┌───────┼─▶│    mutex ■    │  │                           │               
                    │       │  └───────────────┘  │                           │               
                    │       └──────────┬──────────┘                           │               
                    │                  │                                      │               
                 1.lock                │                                      │               
                 mutex                 │                                      │               
                    │                  │                                      │               
                    │                  ▼                                 ┌─────────┐          
┌─────────┐         │          ┌───────────────┐                         │consumer1│          
│producer │─────────┘          │               │                         └─────────┘          
└─────────┘                    │               │                                              
                               │               │                                              
                               │public resource│                                              
                               │               │                                              
                               │               │                                              
                               │               │                                              
                               └───────────────┘                                              
```
6.producer release mutex after accessed public resource
```ditaa
                                                                                   ┌─────────┐
                                       ┌───────────────────────cond_wait───────────│consumer2│
                                       │                                           └─────────┘
                                       │                                                      
                            ┌──────────▼──────────┐                                           
                            │  ┌───────────────┐  │                                           
                            │  │  conditon ■   │◀─┼───────cond_wait───────────┐               
                            │  └───────────────┘  │                           │               
                            │                     │                           │               
                            │                     │                           │               
         2.2.release        │  ┌───────────────┐  │                           │               
     ┌──────mutex───────────┼─▶│    mutex □    │  │                           │               
     │                      │  └───────────────┘  │                           │               
     │                      └──────────┬──────────┘                           │               
     │                                 │                                      │               
     │                                 │                                      │               
     │                                 │                                      │               
     │                                 │                                      │               
     │                                 ▼                                 ┌─────────┐          
┌─────────┐                    ┌───────────────┐                         │consumer1│          
│producer │──────2.1.do        │               │                         └─────────┘          
└─────────┘      logic         │               │                                              
                    │          │               │                                              
                    └─────────▶│public resource│                                              
                               │               │                                              
                               │               │                                              
                               │               │                                              
                               └───────────────┘                                              
```
7.producer cond_broadcast for comsumers. cause condition race
```ditaa
                                                                                   ┌─────────┐
                                       ┌───────────────cond_wait(condition race)───│consumer2│
                                       │                                           └─────────┘
                                       │                                                      
                            ┌──────────▼──────────┐                                           
                            │  ┌───────────────┐  │                                           
     3.cond_broadcast───────┼─▶│  conditon □   │◀─┼──cond_wait(condition race)┐               
     │                      │  └───────────────┘  │                           │               
     │                      │                     │                           │               
     │                      │                     │                           │               
     │                      │  ┌───────────────┐  │                           │               
     │                      │  │    mutex □    │  │                           │               
     │                      │  └───────────────┘  │                           │               
     │                      └──────────┬──────────┘                           │               
     │                                 │                                      │               
     │                                 │                                      │               
     │                                 │                                      │               
     │                                 │                                      │               
     │                                 ▼                                 ┌─────────┐          
┌─────────┐                    ┌───────────────┐                         │consumer1│          
│producer │                    │               │                         └─────────┘          
└─────────┘                    │               │                                              
                               │               │                                              
                               │public resource│                                              
                               │               │                                              
                               │               │                                              
                               │               │                                              
                               └───────────────┘                                              
```
8.consumer1 race succ. lock mutex succ. consumer2 block for mutex lock
```ditaa

                                          2.3.race fail.lock mutex fail.           ┌─────────┐
                      ┌────────────────────────block for lock mutex────────────────│consumer2│
                      │                                                            └─────────┘
                      │                                                                       
                      │     ┌─────────────────────┐                                           
                      │     │  ┌───────────────┐  │                                           
                      │     │  │  conditon □   │  │                                           
                      │     │  └───────────────┘  │                                           
                      │     │                     │                                           
                      │     │                     │                                           
                      │     │  ┌───────────────┐  │2.3.race succ. cond_wait.lock              
                      └─────┼─▶│    mutex ■    │◀─┼─────────mutex succ────────┐               
                            │  └───────────────┘  │                           │               
                            └──────────┬──────────┘                           │               
                                       │                                      │               
                                       │                                      │               
                                       │                                      │               
                                       │                                      │               
                                       ▼                                 ┌─────────┐          
┌─────────┐                    ┌───────────────┐                         │consumer1│          
│producer │                    │               │                         └─────────┘          
└─────────┘                    │               │                                              
                               │               │                                              
                               │public resource│                                              
                               │               │                                              
                               │               │                                              
                               │               │                                              
                               └───────────────┘                                              
```
9.consumer1 release mutex after accessed public resource
```ditaa
                                          2.3.race fail.lock mutex fail.           ┌─────────┐
                      ┌────────────────────────block for lock mutex────────────────│consumer2│
                      │                                                            └─────────┘
                      │                                                                       
                      │     ┌─────────────────────┐                                           
                      │     │  ┌───────────────┐  │                                           
                      │     │  │  conditon □   │  │                                           
                      │     │  └───────────────┘  │                                           
                      │     │                     │                                           
                      │     │                     │                                           
                      │     │  ┌───────────────┐  │                                           
                      └─────┼─▶│    mutex □    │◀─┼──────3.2.unlock mutex─────┐               
                            │  └───────────────┘  │                           │               
                            └──────────┬──────────┘                           │               
                                       │                                      │               
                                       │                                      │               
                                       │                                      │               
                                       │                                      │               
                                       ▼                                 ┌─────────┐          
┌─────────┐                    ┌───────────────┐            ┌────────────┤consumer1│          
│producer │                    │               │            │            └─────────┘          
└─────────┘                    │               │            │                                 
                               │               │  3.1.do    │                                 
                               │public resource│◀─logic─────┘                                 
                               │               │                                              
                               │               │                                              
                               │               │                                              
                               └───────────────┘                                              
```
10.consumer2 lock mutex succ and ....
```ditaa
                                                                                   ┌─────────┐
                      ┌─────────────────────2.3.cond_wati get lock succ────────────│consumer2│
                      │                                                            └─────────┘
                      │                                                                       
                      │     ┌─────────────────────┐                                           
                      │     │  ┌───────────────┐  │                                           
                      │     │  │  conditon □   │  │                                           
                      │     │  └───────────────┘  │                                           
                      │     │                     │                                           
                      │     │                     │                                           
                      │     │  ┌───────────────┐  │                                           
                      └─────┼─▶│    mutex ■    │  │                                           
                            │  └───────────────┘  │                                           
                            └──────────┬──────────┘                                           
                                       │                                                      
                                       │                                                      
                                       │                                                      
                                       │                                                      
                                       ▼                                 ┌─────────┐          
┌─────────┐                    ┌───────────────┐                         │consumer1│          
│producer │                    │               │                         └─────────┘          
└─────────┘                    │               │                                              
                               │               │                                              
                               │public resource│                                              
                               │               │                                              
                               │               │                                              
                               │               │                                              
                               └───────────────┘                                              
```
事实上很可能出现的情况是:consumer在阻塞等待mutex的时候(在上述步骤10)producer顺利lock了mutex.这样会导致consumer继续阻塞.

## 信号量
应用于**线程或进程**间同步.
```cpp
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <pthread.h>
#include <semaphore.h>

#define NUM 5
int a = 5;
sem_t blanc_num,prod_cum;

void *consumer(void *p){
    long int t = (long int)p;
    printf("in consumer\n");
    while(1){
        sem_wait(&prod_cum);
        a--;
        printf("---condumer%ld--a=%d\n ",t,a );
        sem_post(&blanc_num);
        sleep(rand()%4);
    }
    return NULL;
}

void *porducer(void *p){
    printf("in producer\n");
    while(1){
        sem_wait(&blanc_num);
        a++;
        printf("---produce--a=%d\n ",a );
        sem_post(&prod_cum);
        sleep(rand()%4);
    }
    return NULL;
}
int main(int argc, char* argv[])
{
    sem_init(&blanc_num, 0,0);
    sem_init(&prod_cum,0,NUM);
    pthread_t tc,tp;
    pthread_create(&tc, NULL, consumer,(void*)1);
    /* sleep(1); */
    /* pthread_create(&tc, NULL, consumer,(void*)2); */
    sleep(1);
    pthread_create(&tp, NULL, porducer,NULL);

    pthread_join(tc, NULL);
    pthread_join(tp,NULL);
    return 0;
}
```
结果:
```
➜  thread ./sem
in consumer
---condumer1--a=4
 in producer
---produce--a=5
 ---condumer1--a=4
 ---produce--a=5
 ---condumer1--a=4
 ---condumer1--a=3
 ---produce--a=4
 ---produce--a=5
 ---condumer1--a=4
 ---produce--a=5
 ---condumer1--a=4
 ---produce--a=5
```
sem_wait可以认为信号-- -到0的时候就阻塞
sem_post可以认为信号++ 
sem_wait类似加锁,sem_post类似解锁

sem_wait 
- 当信号量>0 --
- 当信号量==0 阻塞
sem_post
- 相当于信号量++
- 如果++到信号默认的最大值,++会阻塞
- 如果信号量从0开始+1,sem_wait的线程或进程可以被唤醒.

**信号量的初值**决定占用信号量的**线程个数**

int sem_init(sem_t *sem, int pshared, unsigned int value)
pshared:是否在进程间被共享.**此时信号量应该放在共享内存中**.

支持trywait和timewait.

//TODO 大版图
