# 线程同步
多个线程访问同一个数据的时候是一致的.要对数据的感知一致.

在线程1对公共数据a进行处理的时候,需要完整处理完后才能让其他线程处理.

线程同步的锁都是**建议锁**,也就是说锁不锁是线程逻辑控制的事情,不会让线程不能访问共享区域的数据.
- 不按照同步规则能访问数据
- 不按照同步规则不保证数据一致

前提:所有处理数据的线程都要用同步机制(锁)

## mutex
#### 函数
- pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
- pthread_mutex_destroy(pthread_mutex_t *mutex);
- pthread_mutex_lock(pthread_mutex_t *mutex);  阻塞进行获取锁
- pthread_mutex_trylock(pthread_mutex_t *mutex) 不阻塞进行获取锁 失败返回EBUSY,锁忙
- pthread_mutex_unlock(pthread_mutex_t *mutex)

pthread_mutex_t 本质是结构体,是现实可以当成整数看待
pthread_mutex mutex变量:只有两种取值:0 1
**注意**`pthread_mutex_init`使用`restrict`修饰符,表示该指针指定的内存区域只能由**本指针**访问.其他同类型的指针不能访问.用于限定指针变量.

操作的时候注意:
while(1){
    [加锁]
    [操作]
    [解锁]
    [**此处应该预留适当的时间空隙交出锁,防止线程占用锁过多**,因为这里下面就是加锁]   
}

可以认为:
初始化后锁值为1.
加锁  -- 加锁失败:阻塞
解锁 ++ 成功:唤醒其他阻塞在锁上的线程
如果<=0,不能再减
try锁:尝试加锁,成功-- 失败不变

注意事项
- 保证锁的粒度越小越好(访问前才加锁,访问后立即解锁)

## 读写锁
写模式加锁,解锁前所有对锁加锁的线程都阻塞
读模式加锁,线程读模式加锁成功,写模式加锁阻塞
读模式加锁,阻塞的读模式加锁和写模式加锁会**优先满足写模式解加锁**


总结阻塞情况
|加锁类型|读模式已锁|写模式已锁|
|----|----|----|
|读模式加锁|成功|阻塞|
|写模式加锁|阻塞|阻塞|

#### 函数
- int pthread_rwlock_destroy(pthread_rwlock_t *rwlock)
- int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
- int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
- int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
- int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
- int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
- int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

解锁只有一个unlock 但是加锁有读或者写锁

对比互斥量而言,读线程多的时候提高访问效率

# 死锁
是一种现象
保证对资源的加锁顺序一致可以保证不会死锁
常见现象:
- 对一个锁反复lock
- 加锁顺序不一致

对一个锁反复lock
```ditaa
             1.lock                 
     ┌────────succ────────────┐     
     │                        │     
     │                        ▼     
┌────────┐    2.lock     ┌─────────┐
│ thread │────again─────▶│  lock   │
└────────┘  ->blocked    └─────────┘
                          ┌────────┐
                          │        │
                          │        │
                          │resource│
                          │        │
                          │        │
                          └────────┘
```
加锁顺序不一致
```ditaa
                                                                
     ┌─1.lock lock1 succ───────┐                                
     │                         │                                
     │                         ▼                                
     │                    ┌─────────┐      2.lock lock1         
     │                    │  lock1  │◀──────-->blocked─────┐    
     │                    └─────────┘                      │    
┌────────┐                                            ┌────────┐
│thread1 │                                            │thread2 │
└────────┘                 ┌─────────┐                └────────┘
     │            ┌───────▶│  lock2  │                     │    
     │     2.lock lock2    └─────────┘                     │    
     └──────-->blocked          ▲                          │    
                                │                          │    
                                └─────1.lock lock2 succ────┘    
                                                                
```

