# 文件IO


## 系统调用

### 操作系统实现并提供给外部应用程序的编程接口

### 完成应用程序用user区到kernel区的权级切换

### write:系统函数.系统调用的浅封装

### sys_write:系统调用

### 应用程序->标库函数->系统调用->驱动->硬件

## 打开/关闭文件

### open()

- 参数

	- 文件路径

		- 相对

		- 绝对

	- flags

		- 读写属性(必选)

			- O_RDONLY

			- O_WRONLY

			- O_RDWR

		- 其他属性(可选)

			- O_APPEND

			- O_EXCL

			- O_TRUNC

			- O_NONBLOCK

			- O_CREAT

				-   指定该选项open有参3 mode

				- Mode指定创建文件的权限

				- Mode类型需要为8进制数据

				- 新文件权限=mode&~unmask

- 返回值

	- 成功

		- 打开文件对应的fd(整数)

			- 是一个已经打开的文件结构体.没有打开的话这个结构体不会在内核产生

	- 失败

		- -1

		- errno

	- 常见错误

		- 文件不存在

		- 写方式打开只读文件(打开文件无对应权限)

		- 以写方式打开目录

### close()

- 参数

	- 已打开的fd

- 返回值

	- 成功 

		- 0

	- 失败

		- -1

		- errno

## fd

### pcb

- 本质是结构体

	- struct task_struct

- 在内核空间,每个进程/线程会有一个pcb

- 成员变量file_struct * file指向fd表

### fd表

- 简单看成数组

- 数组下标:fd(整数)

- 默认最大值:1024

	- ulimit -a查看

- 新打开文件返回fd中可用的最小fd

- 进程产生默认打开3个文件

	- STDIN_FILENO

	- STDOUT_FILENO

	- STDERR_FILENO

## read()/write()

### 系统调用中唯一的”读”,”写”函数

- 库函数很多,但是都不是系统调用

### read()

- 参数

	- fd

	- buff

	- buffsize

		- 接收缓冲区的大小

- 返回

	- >0

		- 实际读到的字节数

	- -1

		- errno=EAGAIN或者EUOULDBLOCK

			- 非阻塞读无数据

		- 不是上述两种

			- gg

	- 0

		- 到文件末尾

### write()

- 参数

	- fd

	- buff

	- buffsize

		- 实际写入的字节长度

- 返回

	- 成功

		- 实际写入字节数

	- 失败

		- -1

		- errno

### 缓冲区

- Unbuffered I/O

	- 无用户级缓冲区

- 标库IO函数自带用户缓冲区

	- fread

	- puts

	- gets

- 内核自带缓冲区

- strace命令

	- 跟踪用到的系统函数

- 预读入,缓输出机制

	- 内核处理,一般是4K

## 错误处理函数

### perror()

- 将参数和当前errno对应的解释拼接成字符串输出到stderr

### strerr()

## 阻塞/非阻塞

### 常规文件不会发生,读终端或者网络可能出现

### 读终端

- 阻塞读

	- 默认情况

- 非阻塞读

	- O_NONBLOCK

- 非阻塞读等待超时

- 上述三种都不是最好的.最好应该是响应模式,fd有变化的时候再去读

## lseek()

### 修改文件读写位置

### 参数

- fd

- 偏移长度

- 起始偏移

	- SEEK_SET

	- SEEK_CUR

	- SEEK_END

### 返回

- 成功

	- 较文件起始位置向后的偏移量

	- 如果偏移到了文件末尾,起始就是文件大小

- 失败

	- -1

	- errno

### 其他常用应用

- 拓展文件大小

	- 1.将文件偏移出大小

	- 2.write操作

		- 会产生文件空洞

- 获取文件长度

	- 起始偏移是SEEK_END,偏移0

## fcntl()

###  不重新打开文件,修改其访问控制属性

### F_GETFL

### F_SETFL

### bitmap设置

## 指针传参

### 传入参数

- const关键字

- 在函数内部读操作

### 传出参数

- 调用前指针指向空间可以无意义,但要求有效

- 调用后指针指向空间有实际意义

- 在函数内部”写”操作

- 作为函数返回值传出

### 传入传出参数

- 调用前指针指向空间有意义

- 在函数内部”读”

- 修改该指针内容(“写”)

- 作为返回值传出


# 文件系统


## 文件存储

### inode

- 本质:结构体

	- 权限

	- 类型

	- 用户

	- 时间

		- 访问时间

		- 内容修改时间

		- 属性修改时间

	- 盘块位置

	- ...

- 存放文件属性信息

### dentry

- 本质:结构体

	- 文件名

	- inode号码

	- ...

### Ext2/ext3/ext4

## 文件操作

### stat()

- 获取文件属性

- 参数

	- 文件名

	- Inode结构体指针struct stat*(传出)

		- inode号:st_ino

		- 属性:st_mode

			- 2字节(short)

			- 特殊权限位

				- 黏着位:sticky

					- 文件(废弃)

					- 目录

						- root

						- 目录所有者

						- 文件所有者

				- 设置用户ID位:setID

					- 有效用户ID:EID

					- 实际用户ID:UID

				- 设置组ID位:setGID

		- 硬连接数

			- st_nlink

		- 用户id

			- st_uid

		- 组id

			- st_gid

		- 大小

			- st_size

		- 文件系统块大小

			- st_blksize

		- 分配扇区个数

			- st_blocks

		- 最后访问时间

			- st_atime

		- 最后修改内容时间

			- st_mtime

		- 最后修改属性事件

			- st_ctime

		- 主设备号

			- st_dev

		- 从设备号

			- st_rdev

- 返回

	- 成功

		- 0

	- 失败

		- -1

		- errno

- 穿透符号链接

### lstat()

- 不穿透符号链接

### truncate()

- 截断文件长度成指定长度

- 拓展文件大小

- 文件必须要存在.不存在truncate失败

### link()

- 创建目录项(硬链接)

- 和dentry相关联

### unlink()

- 删除一个文件的目录项

- 所有打开文件的进程关闭该文件

	- 所有指向这个dentry的inode的连接数位0,没有dentry指向对应的inode了

	- 文件具备了释放的条件

	- 隐式回收系统资源

	- 系统择机释放

## 目录操作

### opendir()

- 返回的是dir*

### closedir()

### readdir()

- 读目录文件的dentry

- 参数

	- 目录结构体指针(opendir返回)

- 返回值

	- 成功

		- struct dirent* 结构体指针

	- 失败

		- NULL

		- errno

- struct dirent

	- d_ino

	- d_name

		- char[256]

		- 因此文件名大小是255

	- ...

### 读写权限在目录和文件上的体现不一样

- 读

	- 目录:读目录项

	- 文件:文件内容

- 写

	- 目录:新建目录项,mv...

	- 文件:写入内容

### 递归遍历目录

## 重定向

### dup()

- 保存fd

- 参数

	- 已经打开的(旧)fd

- 返回

	- 成功

		- 新fd

	- 失败

		- -1

		- errno

### dup2()

- 实现重定向

- 参数

	- 旧fd

	- 新fd

- 返回值

	- 成功

		- 新fd

	- 失败

		- -1

		- errno

### fcntl()

- 修改文件属性

	- flgs=fcntl(fd,F_GET_FL)

	- flgs|=O_NONBLOCK

	- fcntl(fd,F_SETFL,flgs);

- 复制fd

	- F_DUPFD

	- fcntl(fd,F_DUPFD,0/N);


#  网络


## 分层模型

### OSI分层模型

- 物理层

- 数据层

- 网络层

- 传输层

- 会话层

- 表示层

- 应用层

### TCP/IP模型

- 内核

	- 链路层(网络接口层).以太网帧协议

	- 网络层.IP协议

	- 传输层.TCP/UDP协议

- 用户

	- 应用层.FTP/HTTP/telnet协议

## 常见协议格式

### 以太网帧格式

- ARP协议

	- 根据IP地址获取mac地址

- RARP协议

	- 根据mac地址获取IP地址

- 主要格式

	- mac source

	- mac destination

	- 类型

		- 0800:数据报

		- 0806:ARP包

		- 0835:RARP包

	- 1500字节

### IP端格式

- IP:指定网络中唯一一个终端

- 主要格式

	- 4位版本号

		- IPV4

		- IPV6

	- 4位首部长度

	- 16位总长度

	- 8位生存时间

		- TTL:time to live

		- 255

	- 32位源IP

	- 32位目的IP

		- IP地址共4字节

		- 每个字段上限256

### UDP数据报格式

- 主要格式

	- 16位源端口号

	- 16位目的端口号

		- 65535

### TCP数据报格式

- 主要格式

	- 16位源端口号

	- 16位目的端口号

	- 32位序号

	- 32位确认序号

		- 保证数据可靠传输

	- 4位首部长度

	- 标志位

		- SYN

		- ACK

		- FIN

		- RST

		- PUSH

		- ...

	- 16 位窗口大小

		- 65535

## TCP协议

### 通信时序

- 三次握手

	- SYN

	- SYN ACK

	- ACK

- 四次松手

	- FIN

	- ACK

	- FIN

	- ACK

### 滑动窗口

- win

- 流量控制

### MTU

- 最大传输单元

### mss

- 最大报文长度

### 半关闭

- 通信双方的一方单向关闭连接

- 四次松手完成1/2

- shutdown()

	- sockfd

	- how

		- SHUT_RD

			- sockfd不能读 (读不到数据)

		- SHUT_WR

			- 进程不能向socket写数据

				- 此时半关闭

		- SHUT_RDWR

- 进入FIIN_WAIT_2

### TCP状态转换图

- ESTABLISHED

- FIN_WAIT_2

- TIME_WAIT

	- ˙主动关闭连接一方

	- 发出ACK后

	- 2MSL

		- 保证4次握手关闭连接可靠

### 心跳检测

- 心跳包

- 乒乓包

- TCP自带(2小时+11分15s)

### 端口复用

- setsockopt

## socket编程

### 套接字

- Linux特殊文件类型(管道,套接字,字符设备,块设备)

- 文件描述符fd,索引两个缓冲区(读,写)

- 成对出现(C/S,B/S)

- 捆绑IP,端口号(网络)

### socket预备知识

- 网络字节序

	- 大端发(高存低)

	- htonl

		- 本地字节序->网络字节序(IP)

	- htons

		- 本地字节序->网络字节序(端口)

	- ntohl

	- ntohs

- IP地址转换

	- inet_pton

		- 参数

			- af

				- AF_INET

				- AF_INET6

			- src

				- IP地址字符串

			- dst

				- IP地址数字存储形式

		- 返回值

			- 成功

				- 0

			- 失败

				- -1

	- inet_ntop

		- 参数

			- af

				- AF_INET

				- AF_INET6

			- src

				- IP地址数字存储形式(网络中)

			- dst

				- 获取来的IP字符串存储位置

				- 传出参数

			- size

				- dst的大小

		- 返回值

			- 成功

				- dst指针

			- 失败

				- NULL

- sockaddr结构体

	- 过时

	- sockaddr_in结构体

		- 用于捆绑IP,端口号

		- 成员

			- sin_family

				- AF_INET

				- AF_INET6

				- AF_UNIX

			- sin_port

				- 16位整数

			- sin_addr结构体

				- s_addr

				- 32位无符号整数

				- INADDR_ANY

	- sockaddr_in6

### 网络套接字函数

- socket模型流程图

	- client

		- socket()

		- connect()

		- read()

		- write()

		- close()

	- server

		- socket()

		- bind()

			- sockaddr_in

				- sin_family

				- sin_port

				- sin_addr.s_addr

		- listen()

			- 最大128

		- accept()

		- read()

			- 返回0:对端关闭

		- write()

		- close()

- socket()

	- 创建一个套接字

	- 参数

		- domain

			- AF_INET

			- AF_INET_6

			- AF_UNIX,AF_LOCAL

		- type

			- SOCK_STREAM

				- 代表协议:TCP

			- SOCK_DGRAM

				- 代表协议:UDP

		- protocol协议

			- 0表示默认协议

	- 返回值

		- 成功

			- 新创建的socket fd

		- 失败

			- -1

			- errno

- bind()

	- 绑定IP port到套接字

	- 参数

		- sockfd

		- addr

			- 类型:struct sockaddr*

			- 传参

				- 定义 struct sockaddr_in addr

				- 初始化addr成员

					- sin_addr.s_addr

					- sin_port

					- sin_family

				- (struct sockaddr*)&addr 强转

		- addrlen

			- 类型:socklen_t

			- addr大小 sizeof(addr)

	- 返回值

		- 成功

			- 0

		- 失败

			- -1

			- errno

- listen()

	- 允许处于连接状态的client数

	- 参数

		- sockfd

		- backlog

	- 返回

		- 成功

			- 0

		- 失败

			- -1

			- errno

- accept()

	- 阻塞监听客户端连接

	- 参数

		- sockfd

		- addr

			- 客户端地址结构(IP+端口)

			- 传出参数

			- (struct sockaddr*)&addr 强转

		- addrlen

			- addr大小

			- socklen_t类型

			- 传入传出参数

	- 返回值

		- 成功

			- 返回用于与客户端通信的fd

		- 失败

			- -1

			- errno

- connect()

	- 参数

		- sockfd

		- addr

			- 服务器地址结构(IP+端口)

			- 传入参数

			- (struct sockaddr*)&addr强转

		- addrlen

			- addr大小 sizeof(addr)

	- 返回值

		- 成功

			- 0

		- 失败

			- -1

			- errno

## 高并发服务器

### 多进程并发

- 防止僵尸进程

- 捕捉SIGCHLD信号

### 多线程并发

- 线程分离

### 多路IO转接

- select

	- select()

		- 参数

			- ndfs

				- 锁监听的最大fd + 1

					- 性能可能有问题,内核根据ndfs来监听,如果剩下fd是3 1000,事实上会轮训了到1001

			- readfds

				- 有数据刻度的fd集合(传入,传出)

			- writefds

				- 可写的fd集合(传入,传出)

					- lfd可读:有连接请求进来.

					- cfd可读:说明cli往socket写数据

			- exceptfds

				- 有异常发生的fd集合(传入,传出)

					- 主要供内核使用,日常使用较少

			- timeout

				- NULL:永久等待

				- 0 不阻塞

				- 具体时间:阻塞时间

		- 返回值

			- 成功

				- 所有监听集合中满足条件的总数

			- 失败

				- -1

				- errno

	- fd_set类型

	- 辅助函数

		- FD_ZERO

			- 清空集合

		- FD_SET

			- 将某个fd加入集合

		- FD_CLR

			- 将某个fd清出集合

		- FD_ISSET

			- 判断fd是否在集合中

				- 每次都要调用方自己判定,传入还要重新传.效率不高

- poll

	- struct pollfd结构体

		- fd

			- 要监听的fd

		- events

			- 监听该fd什么事件

				- POLLIN

				- POLLOUT

				- POLLERR

		- reevents

			- 满足条件返回的事件

	- poll()

		- 参数

			- fds

				- 监控数组

			- nfds

				- 监控数组中需要监控的fd数量

			- timeout

				- -1:阻塞等

				- 0:立即返回

				- >0 等待时长

		- 返回值

			- 成功

				- 所有监听集合中满足条件的fd数

			- 失败

				- -1

				- errno

	- 比较select()优势

		- 突破1024限制

		- 传入,传出事件分离

- 修改进程打开fd

	- 查看

		- cat /proc/sys/fs/file_max

			- 硬件限制-物理层面

		- ulimit -a

			- openfiles,软件限制

	- 修改

		- sudo  vi /etc/srcurity/limits.conf

		- *soft nofile 8000

			- 设定默认打开fd数

		- * hard nofile 10000

			- 限定命令临时修改上限

			- ulimit -n xxxx

		- 重启,注销用户

- epoll

	- epoll_create

		- 创建一棵监听红黑树

			- 根:epfd

		- 参数size:希望监听的fd个数(内核参考值)

		- 返回值

			- 成功

				- 新创建的监听红黑树对应的fd epfd

			- 失败

				- -1

				- errno

	- epoll_ctl

		- 参数

			- epfd

				- epoll_create返回的监听树epfd

			- op:操作动作

				- EPOLL_CTL_ADD

					- 添加一个新fd到监听红黑树

				- EPOLL_CTL_MOD

					- 修改一个已经监听fd的监听事件

				- EPOLL_CTL_DEL

					- 从epfd清出一个监听fd

			- fd

				- 待监听fd

			- event

				- 需要监听的事件

				- 类型:struct epoll_event

				- 成员

					- events

						- EOPLLIN

						- EPOLLOUT

						- EPOLLERR

					- data

						- union

							- 用户自定义信息,用于回调事件

						- int fd

						- void *ptr

						- uint32_t u32

						- uint64_t u64

		- 返回值

			- 成功

				- 0

			- 失败

				- -1

				- errno

	- eopll_wait

		- 参数

			- epfd

				- eopll_create返回的监听树fd

			- events

				- 传出参数,传出满足监听事件的数组

			- maxevents

				- 数组元素总个数

			- timeout

				- -1 阻塞

				- 0 不阻塞

				- >0 指定毫秒阻塞

		- 返回

			- 成功

				- 满足监听条件的fd总数,用作数组循环上限

			- 0

				- timeout时间到

			- 失败

				- -1

				- errno

	- 优势

		- 突破1024限制

		- 事件分离

- eopll进阶

	- epoll_ET

		- Fd可以可读触发或者可写触发才会响应

		- 关注事件触发,fd的内容变动

		- 对于读监听,必须是有写进程触发过fd才可以被读监听侧监听到

	- epoll-LT

		- 默认

		- Fd可写或者可读就会响应,不需要事件触发

		- 只要fd内有数据,读监听侧就会收到监听触发

	- 非阻塞IO+ET

		- ET

			- EPOLLIN|EPOLLET

		- 非阻塞

			- flg=fcntl(fd,F_GETFL)

			- flg |= O_NONBLOCK

			- fcntl(fd,F_SETFL,flg)

	- epoll反应堆模型

		- 监听事件变化

			- EPOLLIN 转为 EPOLLOUT

			- 事件被触发之后,需要先从监听树上摘下来,从新挂在树上

			- 所有事件,包括lfd的监听,都使用eopll完成

			- 依靠epoll挂在树上的时候的event结构体,可以返回用户指定的内容,在里面挂上调用函数,达到反应的目的

		- 回调函数

			- 自动反应

- 线程池

	- threadpool_task_t

		- 全局总控

	- main

		- threadpool_create创建线程池

		- for产生任务

			- 阻塞在queue_not_full条件变量上

		- threadpool_add添加任务

		- threadpool_destroy销毁线程

	- threadpool_create()

	- threadpool_thread()

		- 跟踪到pthread_cond_wait()阻塞

			- 阻塞在queue_not_empty条件变量上

	- threadpool_add()

		- 跟踪到pthread_cond_signal(), 回上步,继续pthread_cond_wait()

	- adjust_thread

		- 根据线程数量和alive线程数调整线程

			- pthread_exit()

	- thread_destroy

		- 销毁整个线程池

			- pthread_exit()

## UDP

### 协议对比

- TCP

	- 面向连接的可靠数据传输

		- 针对不稳定的网络层,依靠重发弥补

	- 优点

		- 稳定

			- 正确率

				- 丢包重传

			- 传递顺序

			- 流量

	- 缺点

		- 开销大

		- 速度慢

	- 使用场所

		- 大文件

		- 重要文件

- UDP

	- 无连接的不可靠报文传递

		- 针对不稳定网络层,完全不弥补

	- 优点

		- 开销小

		- 速度快

		- 效率高

		- 实时性强

	- 缺点

		- 不稳定

			- 正确率

				- 丢包不作为

			- 传递不按顺序

			- 流量不进行控制

	- 使用场所

		- 实时性较强

		- 游戏

		- 视频电话,会议

### UDP c/s服务器

- 通信步骤

	- server

		- socket()

		- bind()

			- 绑定IP port

		- recvfrom()

			- 接收数据

		- sendto()

			- 回发数据

	- client

		- socket()

		- 隐式绑定

		- sendto()

			- 发送数据

- recvfrom()

	- 参数

		- sockfd

		- buf

		- len:bufsize

		- flags:0

		- src_addr

			- 对端地址结构体(传出)

		- addrlen

			- 地址结构大小(传入传出)

	- 返回值

		- 实际接收字节数

- sendto()

	- 参数

		- sockfd

		- buf

		- len:bufsize

		- flags:0

		- dest_addr

			- 服务器端的地址结构(传入),参数不能省略

		- addrlen

			- 地址结构大小

	- 返回值

		- 实际发送字节数

- 默认支持多路IO

- 无连接:无状态

	- netstat-apn

	- TCP状态时序图

- send,recv只能用于TCP连接的C/S模型

## 本地套接字

### socket()

- AF_UNIX/AF_LOCAL

### bind()

- sockaddr_un

	- sun_family

		- AF_UNIX

	- sun_path

		- “path”

- (struct sockaddr*)&addr

- len

	- offset()

		- 结构体成员首地址偏移

		- 获取AF_UNIX大小

		- offsetof(struct sockaddr_un,sun_path)

	- strlen()

		- 实际socket文件大小

- 创建socket文件

	- 先unlink,确保bind成功

### 客户端

- 不能依赖隐式绑定

- 2次地址结构初始化

	- client_addr

		- bind()

	- server_addr

		- connent()

### 对比网络socket和本地socket


# 线程同步


## 线程同步概念

### 协同步调,按预定先后次序执行

### 与时间有关的错误

### 数据混乱

- 资源共享

- 随机调度

- 缺乏必要的同步机制

### 多个控制流访问同一共享资源,必须同步

## 互斥量(互斥锁)

### mutex

- 建议锁

- 锁,不会限制资源访问

- 线程不按规则访问数据依然成功,但是会出现数据混乱

### 函数

- pthread_mutex_t类型

	- 本质:结构体

	- 简化:1,0

- 返回值:

	- 成功

		- 0

	- 失败

		- errno

- pthread_mutex_init

	- 初始化一把互斥锁

		- 1

	- 参数

		- 互斥锁mutex(传出)

		- 互斥锁属性(传入)

			- 默认属性NULL

		- restrict关键字

			- 所有修改该指针指向内存内容的操作,只能通过本指针完成

	- 适合放在函数内使用

- 静态初始化

	- PTHREAD_MUTEX_INITIALIZER

	- 适合放在全局变量使用

- pthread_mutex_destroy

	- 销毁一个互斥锁

	- 参数

		- &mutex

- pthread_mutex_lock

	- 加锁

	- 参数

		- &mutex

	- mutex - -

	- 减为0之后再加锁:阻塞

- pthread_mutex_unlock

	- 解锁

	- 参数

		- &mutex

	- mutex++

	- 同时将阻塞在该锁的所有线程唤醒

- pthread_mutex_trylock

	- 非阻塞加锁

	- 参数

		- &mutex

	- mutex++

- 锁的”粒度”(临界区)

	- 越小越好

	- 访问公共资源之前加锁,访问后立即解锁

## 死锁

### 产生原因

- 对同一个互斥量反复加锁

- A锁1后锁2,B锁2后锁1

### 避免方法

- 保证资源获取顺序,每个资源对锁的获取顺序一致

- 得不到更多需要资源时候放弃锁,等待

## 读写锁

### 使用要领

- 读共享,写独占

- 写锁优先级高,一起等待的话写锁线程先被唤醒

### 状态

- 读模式下加锁  读锁

- 写模式下加锁  写锁

- 不加锁状态

### 特性

- 写模式加锁

	- 解锁前,所有对该所加锁的线程都会阻塞

- 读模式加锁

	- 线程以写模式加锁,阻塞

	- 线程以多模式加锁,成功

- 写锁读锁同时阻塞:锁释放后优先满足写锁

### 使用场景

- 适合对数据结构读次数大于写

### 函数

- pthread_rwlock_t

- 返回

	- 成功

		- 0

	- 失败

		- errno

- 参数

	- 都是 &rwlock

- pthread_rwlock_init

	- 参数

		- &rwlock

		- 属性attr (NULL)

- pthread_rwlock_destroy

- pthread_rwlock_rdlock

- pthread_rwlock_wrlock

- pthread_rwlock_tryrdlock

- pthread_rwlock_trywrlock

- pthread_rwlock_unlock

## 条件变量

### 特性

- 不是锁

- 可以造成线程阻塞

- 与mutex配合使用

### 函数

- pthread_cond_t

- 返回

	- 成功

		- 0

	- 失败

		- errno

- pthread_cond_init

	- 参数

		- &cond

		- 属性attr (NULL)

- pthread_cond_destroy

- pthread_cond_wait

	- 阻塞等待一个条件变量

	- 参数

		- &cond

		- &mutex

	- 作用

		- 1.释放已经掌握的mutex

		- 2.阻塞等待条件变量

		- 3.被唤醒时候重新获取互斥锁

		- 1.2.是原子操作

- pthread_cond_timewait

	- 参数3

		- abstime

			- 绝对时间

			- struct timespec

				- tv_sec 秒

				- tv_usec 微妙

			- 使用方法

				- time_t cur = time(NULL)

				- struct timespec t

				- pthread_cond_timewait(...)

- pthread_cond_signal

	- 唤醒(至少)一条阻塞在条件变量上的线程

- pthread_cond_breadcast

	- 唤醒全部阻塞在条件变量上的线程

	- 尽量少用,手动惊群

### 生产者消费者模型

### 有点:减少不必要的竞争

## 信号量

### sem

- 进化版互斥锁(1->N)

- 保证同步同时,提高并发

- 多个线程进入共享区需要保证访问处理不混乱,要指定访问先后顺序

- 支持进程,需要放shm

### 函数

- sem_t

	- 本质结构体

	- N表示线程数量

	- N不能<0

	- #include <semaphore.h>

- sem_init

	- 参数

		- &sem

		- 是否在进程间共享

			- 非0进程间(PTHREAD_PROCSS_SHARED)

			- 0线程间(PTHREAD_PROCESS_PRIVATE)

		- N线程数

- sem_destroy

- sem_wait

	- 给信号量加锁

		- sem - - lock

- sem_trywait

- sem_timewait

- sem_post

	- 给信号量解锁 sem ++ unlock

	- 唤醒阻塞在信号量上的线程

### 生产者消费者模型

